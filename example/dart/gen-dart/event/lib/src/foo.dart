/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library event.src.foo;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:thrift/thrift.dart';
import 'package:event/event.dart';
import 'package:base/base.dart';


/// This is a thrift service. Frugal will generate bindings that include
/// a frugal Context for each service call.
abstract class Foo extends BaseFoo {

  /// Ping the server.
  Future ping();

  /// Blah the server.
  /// 
  /// @param num
  /// @param str
  /// @param event
  Future<int> blah(int num, String str, Event event);

  /// oneway methods don't receive a response from the server.
  /// 
  /// @param id
  /// @param req
  Future oneWay(int id, Map<int, String> req);
}

class FooClient extends BaseFooClient implements Foo {

  FooClient(TProtocol iprot, [TProtocol oprot = null])
    : super(iprot, oprot);

  Future ping() async {
    oprot.writeMessageBegin(new TMessage("ping", TMessageType.CALL, nextSeqid()));
    ping_args args = new ping_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    ping_result result = new ping_result();
    result.read(iprot);
    iprot.readMessageEnd();
    return;
  }

  Future<int> blah(int num, String str, Event event) async {
    oprot.writeMessageBegin(new TMessage("blah", TMessageType.CALL, nextSeqid()));
    blah_args args = new blah_args();
    args.num = num;
    args.str = str;
    args.event = event;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    blah_result result = new blah_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.awe != null) {
      throw result.awe;
    }
    if (result.api != null) {
      throw result.api;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "blah failed: unknown result");
  }

  Future oneWay(int id, Map<int, String> req) async {
    oprot.writeMessageBegin(new TMessage("oneWay", TMessageType.ONEWAY, nextSeqid()));
    oneWay_args args = new oneWay_args();
    args.id = id;
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class FooProcessor extends BaseFooProcessor implements TProcessor {
  FooProcessor(Foo iface)
    : super(iface) {
    PROCESS_MAP["ping"] = ping;
    PROCESS_MAP["blah"] = blah;
    PROCESS_MAP["oneWay"] = oneWay;
  }

  Foo iface_;

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  ping(int seqid, TProtocol iprot, TProtocol oprot) {
    ping_args args = new ping_args();
    args.read(iprot);
    iprot.readMessageEnd();
    ping_result result = new ping_result();
    iface_.ping();
    oprot.writeMessageBegin(new TMessage("ping", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  blah(int seqid, TProtocol iprot, TProtocol oprot) async {
    blah_args args = new blah_args();
    args.read(iprot);
    iprot.readMessageEnd();
    blah_result result = new blah_result();
    try {
      result.success = await iface_.blah(args.num, args.str, args.event);
    } on AwesomeException catch(awe) {
      result.awe = awe;
    } on api_exception catch(api) {
      result.api = api;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing blah");
      oprot.writeMessageBegin(new TMessage("blah", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("blah", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  oneWay(int seqid, TProtocol iprot, TProtocol oprot) {
    oneWay_args args = new oneWay_args();
    args.read(iprot);
    iprot.readMessageEnd();
    iface_.oneWay(args.id, args.req);
    return;
  }

}

class ping_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("ping_args");



  ping_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("ping_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ping_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("ping_result");



  ping_result() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);


    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("ping_result(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class blah_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("blah_args");
  static final TField _NUM_FIELD_DESC = new TField("num", TType.I32, 1);
  static final TField _STR_FIELD_DESC = new TField("Str", TType.STRING, 2);
  static final TField _EVENT_FIELD_DESC = new TField("event", TType.STRUCT, 3);

  int _num;
  static const int NUM = 1;
  String _str;
  static const int STR = 2;
  Event _event;
  static const int EVENT = 3;

  bool __isset_num = false;

  blah_args() {
  }

  // num
  int get num => this._num;

  set num(int num) {
    this._num = num;
    this.__isset_num = true;
  }

  bool isSetNum() => this.__isset_num;

  unsetNum() {
    this.__isset_num = false;
  }

  // str
  String get str => this._str;

  set str(String str) {
    this._str = str;
  }

  bool isSetStr() => this.str != null;

  unsetStr() {
    this.str = null;
  }

  // event
  Event get event => this._event;

  set event(Event event) {
    this._event = event;
  }

  bool isSetEvent() => this.event != null;

  unsetEvent() {
    this.event = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case NUM:
        return this.num;
      case STR:
        return this.str;
      case EVENT:
        return this.event;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case NUM:
        if (value == null) {
          unsetNum();
        } else {
          this.num = value;
        }
        break;

      case STR:
        if (value == null) {
          unsetStr();
        } else {
          this.str = value;
        }
        break;

      case EVENT:
        if (value == null) {
          unsetEvent();
        } else {
          this.event = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case NUM:
        return isSetNum();
      case STR:
        return isSetStr();
      case EVENT:
        return isSetEvent();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case NUM:
          if (field.type == TType.I32) {
            this.num = iprot.readI32();
            this.__isset_num = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STR:
          if (field.type == TType.STRING) {
            this.str = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EVENT:
          if (field.type == TType.STRUCT) {
            this.event = new Event();
            this.event.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    if (!__isset_num) {
        throw new TProtocolError(TProtocolErrorType.UNKNOWN, "Required field 'num' was not found in serialized data! Struct: " + toString());
    }

    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_NUM_FIELD_DESC);
    oprot.writeI32(this.num);
    oprot.writeFieldEnd();
    if (this.str != null) {
      oprot.writeFieldBegin(_STR_FIELD_DESC);
      oprot.writeString(this.str);
      oprot.writeFieldEnd();
    }
    if (this.event != null) {
      oprot.writeFieldBegin(_EVENT_FIELD_DESC);
      this.event.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blah_args(");

    ret.write("num:");
    ret.write(this.num);

    ret.write(", ");
    ret.write("str:");
    if (this.str == null) {
      ret.write("null");
    } else {
      ret.write(this.str);
    }

    ret.write(", ");
    ret.write("event:");
    if (this.event == null) {
      ret.write("null");
    } else {
      ret.write(this.event);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // alas, we cannot check 'num' because it's a primitive and you chose the non-beans generator.
    if (str == null) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "Required field 'str' was not present! Struct: " + toString());
    }
    if (event == null) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "Required field 'event' was not present! Struct: " + toString());
    }
    // check that fields of type enum have valid values
  }

}

class blah_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("blah_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.I64, 0);
  static final TField _AWE_FIELD_DESC = new TField("awe", TType.STRUCT, 1);
  static final TField _API_FIELD_DESC = new TField("api", TType.STRUCT, 2);

  int _success;
  static const int SUCCESS = 0;
  AwesomeException _awe;
  static const int AWE = 1;
  api_exception _api;
  static const int API = 2;

  bool __isset_success = false;

  blah_result() {
  }

  // success
  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  // awe
  AwesomeException get awe => this._awe;

  set awe(AwesomeException awe) {
    this._awe = awe;
  }

  bool isSetAwe() => this.awe != null;

  unsetAwe() {
    this.awe = null;
  }

  // api
  api_exception get api => this._api;

  set api(api_exception api) {
    this._api = api;
  }

  bool isSetApi() => this.api != null;

  unsetApi() {
    this.api = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case AWE:
        return this.awe;
      case API:
        return this.api;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case AWE:
        if (value == null) {
          unsetAwe();
        } else {
          this.awe = value;
        }
        break;

      case API:
        if (value == null) {
          unsetApi();
        } else {
          this.api = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case AWE:
        return isSetAwe();
      case API:
        return isSetApi();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AWE:
          if (field.type == TType.STRUCT) {
            this.awe = new AwesomeException();
            this.awe.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case API:
          if (field.type == TType.STRUCT) {
            this.api = new api_exception();
            this.api.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetAwe()) {
      oprot.writeFieldBegin(_AWE_FIELD_DESC);
      this.awe.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetApi()) {
      oprot.writeFieldBegin(_API_FIELD_DESC);
      this.api.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blah_result(");

    ret.write("success:");
    ret.write(this.success);

    ret.write(", ");
    ret.write("awe:");
    if (this.awe == null) {
      ret.write("null");
    } else {
      ret.write(this.awe);
    }

    ret.write(", ");
    ret.write("api:");
    if (this.api == null) {
      ret.write("null");
    } else {
      ret.write(this.api);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class oneWay_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("oneWay_args");
  static final TField _ID_FIELD_DESC = new TField("id", TType.I64, 1);
  static final TField _REQ_FIELD_DESC = new TField("req", TType.MAP, 2);

  int _id;
  static const int ID = 1;
  Map<int, String> _req;
  static const int REQ = 2;

  bool __isset_id = false;

  oneWay_args() {
  }

  // id
  int get id => this._id;

  set id(int id) {
    this._id = id;
    this.__isset_id = true;
  }

  bool isSetId() => this.__isset_id;

  unsetId() {
    this.__isset_id = false;
  }

  // req
  Map<int, String> get req => this._req;

  set req(Map<int, String> req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ID:
        return this.id;
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          this.id = value;
        }
        break;

      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case ID:
        return isSetId();
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case ID:
          if (field.type == TType.I64) {
            this.id = iprot.readI64();
            this.__isset_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REQ:
          if (field.type == TType.MAP) {
            {
              TMap _map0 = iprot.readMapBegin();
              this.req = new Map<int, String>();
              for (int _i1 = 0; _i1 < _map0.length; ++_i1) {
                int _key2;
                String _val3;
                _key2 = iprot.readI32();
                _val3 = iprot.readString();
                this.req[_key2] = _val3;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    if (!__isset_id) {
        throw new TProtocolError(TProtocolErrorType.UNKNOWN, "Required field 'id' was not found in serialized data! Struct: " + toString());
    }

    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ID_FIELD_DESC);
    oprot.writeI64(this.id);
    oprot.writeFieldEnd();
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, this.req.length));
        for (var elem5 in this.req.keys) {
          oprot.writeI32(elem5);
          oprot.writeString(this.req[elem5]);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("oneWay_args(");

    ret.write("id:");
    ret.write(this.id);

    ret.write(", ");
    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // alas, we cannot check 'id' because it's a primitive and you chose the non-beans generator.
    if (req == null) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "Required field 'req' was not present! Struct: " + toString());
    }
    // check that fields of type enum have valid values
  }

}

