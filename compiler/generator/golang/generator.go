/*
 * Copyright 2017 Workiva
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package golang

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"unicode"

	"golang.org/x/tools/imports"

	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/globals"
	"github.com/Workiva/frugal/compiler/parser"
)

const (
	lang                = "go"
	defaultOutputDir    = "gen-go"
	serviceSuffix       = "_service"
	scopeSuffix         = "_scope"
	packagePrefixOption = "package_prefix"
	thriftImportOption  = "thrift_import"
	frugalImportOption  = "frugal_import"
	asyncOption         = "async"
	useVendorOption     = "use_vendor"
)

// Generator implements the LanguageGenerator interface for Go.
type Generator struct {
	*generator.BaseGenerator
	generateConstants bool
	typesFile         *os.File
}

// NewGenerator creates a new Go LanguageGenerator.
func NewGenerator(options map[string]string) generator.LanguageGenerator {
	return &Generator{&generator.BaseGenerator{Options: options}, true, nil}
}

// SetupGenerator initializes globals the generator needs, like the types file.
func (g *Generator) SetupGenerator(outputDir string) error {
	g.generateConstants = true
	t, err := g.GenerateFile("", outputDir, generator.TypeFile)
	if err != nil {
		return err
	}
	g.typesFile = t
	if err = g.GenerateDocStringComment(g.typesFile); err != nil {
		return err
	}
	if err = g.GenerateNewline(g.typesFile, 2); err != nil {
		return err
	}
	if err = g.generatePackage(g.typesFile); err != nil {
		return err
	}
	if err = g.GenerateNewline(g.typesFile, 2); err != nil {
		return err
	}
	if err = g.GenerateTypesImports(g.typesFile); err != nil {
		return err
	}
	if err = g.GenerateNewline(g.typesFile, 2); err != nil {
		return err
	}

	return nil
}

// TeardownGenerator cleanups globals the generator needs, like the types file.
func (g *Generator) TeardownGenerator() error {
	defer g.typesFile.Close()
	return g.PostProcess(g.typesFile)
}

// GetOutputDir returns the output directory for generated files.
func (g *Generator) GetOutputDir(dir string) string {
	if namespace := g.Frugal.Namespace(lang); namespace != nil {
		path := generator.GetPackageComponents(namespace.Value)
		dir = filepath.Join(append([]string{dir}, path...)...)
	} else {
		dir = filepath.Join(dir, g.Frugal.Name)
	}
	return dir
}

// DefaultOutputDir returns the default output directory for generated files.
func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

// PostProcess file runs gofmt and goimports on the given file.
func (g *Generator) PostProcess(f *os.File) error {
	contents, err := ioutil.ReadFile(f.Name())
	if err != nil {
		return err
	}
	contents, err = imports.Process(f.Name(), contents, nil)
	if err != nil {
		return err
	}
	return ioutil.WriteFile(f.Name(), contents, 0)
}

// GenerateDependencies is a no-op.
func (g *Generator) GenerateDependencies(dir string) error {
	return nil
}

// GenerateFile generates the given FileType.
func (g *Generator) GenerateFile(name, outputDir string, fileType generator.FileType) (*os.File, error) {
	switch fileType {
	case generator.CombinedServiceFile:
		return g.CreateFile(strings.ToLower(name)+serviceSuffix, outputDir, lang, true)
	case generator.CombinedScopeFile:
		return g.CreateFile(strings.ToLower(name)+scopeSuffix, outputDir, lang, true)
	case generator.TypeFile:
		return g.CreateFile("types", outputDir, lang, true)
	case generator.ServiceArgsResultsFile:
		return g.CreateFile(strings.ToLower(name), outputDir, lang, true)
	default:
		return nil, fmt.Errorf("Bad file type for golang generator: %s", fileType)
	}
}

// GenerateDocStringComment generates the autogenerated notice.
func (g *Generator) GenerateDocStringComment(file *os.File) error {
	comment := fmt.Sprintf(
		"// Autogenerated by Frugal Compiler (%s)\n"+
			"// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING",
		globals.Version)

	_, err := file.WriteString(comment)
	return err
}

// GenerateServicePackage generates the package for the given service.
func (g *Generator) GenerateServicePackage(file *os.File, s *parser.Service) error {
	return g.generatePackage(file)
}

// GenerateScopePackage generates the package for the given scope.
func (g *Generator) GenerateScopePackage(file *os.File, s *parser.Scope) error {
	return g.generatePackage(file)
}

func (g *Generator) generatePackage(file *os.File) error {
	pkg := ""
	namespace := g.Frugal.Namespace(lang)
	if namespace != nil {
		components := generator.GetPackageComponents(namespace.Value)
		pkg = components[len(components)-1]
	} else {
		pkg = g.Frugal.Name
	}
	_, err := file.WriteString(fmt.Sprintf("package %s", pkg))
	return err
}

// GenerateConstantsContents generates constants.
func (g *Generator) GenerateConstantsContents(constants []*parser.Constant) error {
	// Use a const expression for basic types and an init function for complex
	// or typedef'd types
	contents := ""
	initfunc := "func init() {\n"

	for _, constant := range constants {
		if constant.Comment != nil {
			contents += g.GenerateInlineComment(constant.Comment, "")
		}

		cName := title(constant.Name)
		value := g.generateConstantValue(constant.Type, constant.Value)
		// Don't use underlying type so typedefs aren't consts
		if (constant.Type.IsPrimitive() || g.Frugal.IsEnum(constant.Type)) && constant.Type.Name != "binary" {
			contents += fmt.Sprintf("const %s = %s\n\n", cName, value)
		} else {
			contents += fmt.Sprintf("var %s %s\n\n", cName, g.getGoTypeFromThriftType(constant.Type))
			initfunc += fmt.Sprintf("\t%s = %s\n", cName, value)
		}
	}

	initfunc += "}\n\n"
	contents += initfunc

	g.typesFile.WriteString(contents)
	return nil
}

// quote creates a Go string literal for a string.
func (g *Generator) quote(s string) string {
	return strconv.Quote(s);
}

// generateConstantValue recursively generates the string representation of
// a, possibly complex, constant value.
func (g *Generator) generateConstantValue(t *parser.Type, value interface{}) string {
	// If the value being referenced is of type Identifier, it's referencing
	// another constant.
	identifier, ok := value.(parser.Identifier)
	if ok {
		idCtx := g.Frugal.ContextFromIdentifier(identifier)
		switch idCtx.Type {
		case parser.LocalConstant:
			return title(idCtx.Constant.Name)
		case parser.LocalEnum:
			return fmt.Sprintf("%s_%s", title(idCtx.Enum.Name), idCtx.EnumValue.Name)
		case parser.IncludeConstant:
			include := idCtx.Include.Name
			if namespace := g.Frugal.NamespaceForInclude(include, lang); namespace != nil {
				include = namespace.Value
			}
			return fmt.Sprintf("%s.%s", includeNameToReference(include), title(idCtx.Constant.Name))
		case parser.IncludeEnum:
			include := idCtx.Include.Name
			if namespace := g.Frugal.NamespaceForInclude(include, lang); namespace != nil {
				include = namespace.Value
			}
			return fmt.Sprintf("%s.%s_%s", includeNameToReference(include), title(idCtx.Enum.Name), idCtx.EnumValue.Name)
		default:
			panic(fmt.Sprintf("The Identifier %s has unexpected type %d", identifier, idCtx.Type))
		}
	}

	underlyingType := g.Frugal.UnderlyingType(t)
	if underlyingType.IsPrimitive() || underlyingType.IsContainer() {
		switch underlyingType.Name {
		case "bool", "i8", "byte", "i16", "i32", "i64", "double":
			return fmt.Sprintf("%v", value)
		case "string":
			return g.quote(value.(string))
		case "binary":
			return fmt.Sprintf("[]byte(\"%s\")", value)
		case "list":
			contents := ""
			contents += fmt.Sprintf("%s{\n", g.getGoTypeFromThriftType(underlyingType))
			for _, v := range value.([]interface{}) {
				val := g.generateConstantValue(underlyingType.ValueType, v)
				contents += fmt.Sprintf("%s,\n", val)
			}
			contents += "}"
			return contents
		case "set":
			contents := ""
			contents += fmt.Sprintf("%s{\n", g.getGoTypeFromThriftType(underlyingType))
			for _, v := range value.([]interface{}) {
				val := g.generateConstantValue(underlyingType.ValueType, v)
				contents += fmt.Sprintf("%s: true,\n", val)
			}
			contents += "}"
			return contents
		case "map":
			contents := ""
			contents += fmt.Sprintf("%s{\n", g.getGoTypeFromThriftType(underlyingType))
			for _, pair := range value.([]parser.KeyValue) {
				key := g.generateConstantValue(underlyingType.KeyType, pair.Key)
				val := g.generateConstantValue(underlyingType.ValueType, pair.Value)
				contents += fmt.Sprintf("%s: %s,\n", key, val)
			}
			contents += "}"
			return contents
		}
	} else if g.Frugal.IsEnum(underlyingType) {
		return fmt.Sprintf("%d", value)
	} else if g.Frugal.IsStruct(underlyingType) {
		s := g.Frugal.FindStruct(underlyingType)
		if s == nil {
			panic("no struct for type " + underlyingType.Name)
		}

		contents := ""
		contents += fmt.Sprintf("&%s{\n", title(s.Name))

		for _, pair := range value.([]parser.KeyValue) {
			name := title(pair.KeyToString())
			for _, field := range s.Fields {
				if name == title(field.Name) {
					val := g.generateConstantValue(field.Type, pair.Value)
					contents += fmt.Sprintf("\t%s: %s,\n", name, val)
				}
			}
		}

		contents += "}"
		return contents
	}

	panic("no entry for type " + underlyingType.Name)
}

// GenerateTypeDef generates the given typedef.
func (g *Generator) GenerateTypeDef(typedef *parser.TypeDef) error {
	contents := ""

	if typedef.Comment != nil {
		contents += g.GenerateInlineComment(typedef.Comment, "")
	}

	contents += fmt.Sprintf("type %s %s\n", title(typedef.Name), g.getGoTypeFromThriftType(typedef.Type))
	_, err := g.typesFile.WriteString(contents)
	return err
}

// GenerateEnum generates the given enum.
func (g *Generator) GenerateEnum(enum *parser.Enum) error {
	// An enum is basically a typedef for int with a couple constants and functions
	contents := ""

	if enum.Comment != nil {
		contents += g.GenerateInlineComment(enum.Comment, "")
	}

	eName := title(enum.Name)
	contents += fmt.Sprintf("type %s int64\n\n", eName)
	contents += "const (\n"
	for _, field := range enum.Values {
		if field.Comment != nil {
			contents += g.GenerateInlineComment(field.Comment, "\t")
		}
		contents += fmt.Sprintf("\t%s_%s %s = %d\n", eName, field.Name, eName, field.Value)
	}
	contents += ")\n\n"

	contents += fmt.Sprintf("func (p %s) String() string {\n", eName)
	contents += "\tswitch p {\n"
	for _, field := range enum.Values {
		contents += fmt.Sprintf("\tcase %s_%s:\n", eName, field.Name)
		contents += fmt.Sprintf("\t\treturn \"%s\"\n", field.Name)
	}
	contents += "\t}\n"
	contents += "\treturn \"<UNSET>\"\n"
	contents += "}\n\n"

	contents += fmt.Sprintf("func %sFromString(s string) (%s, error) {\n", eName, eName)
	contents += "\tswitch s {\n"
	for _, field := range enum.Values {
		contents += fmt.Sprintf("\tcase \"%s\":\n", field.Name)
		contents += fmt.Sprintf("\t\treturn %s_%s, nil\n", eName, field.Name)
	}
	contents += "\t}\n"
	contents += fmt.Sprintf("\treturn %s(0), fmt.Errorf(\"not a valid %s string\")\n", eName, eName)
	contents += "}\n\n"

	contents += fmt.Sprintf("func (p %s) MarshalText() ([]byte, error) {\n", eName)
	contents += "\treturn []byte(p.String()), nil\n"
	contents += "}\n\n"

	contents += fmt.Sprintf("func (p *%s) UnmarshalText(text []byte) error {\n", eName)
	contents += fmt.Sprintf("\tq, err := %sFromString(string(text))\n", eName)
	contents += "\tif err != nil {\n"
	contents += "\t\treturn err\n"
	contents += "\t}\n"
	contents += "\t*p = q\n"
	contents += "\treturn nil\n"
	contents += "}\n\n"

	contents += fmt.Sprintf("func (p *%s) Scan(value interface{}) error {\n", eName)
	contents += "\tv, ok := value.(int64)\n"
	contents += "\tif !ok {\n"
	contents += "\t\treturn errors.New(\"Scan value is not int64\")\n"
	contents += "\t}\n"
	contents += fmt.Sprintf("\t*p = %s(v)\n", eName)
	contents += fmt.Sprintf("\treturn nil\n")
	contents += "}\n\n"

	contents += fmt.Sprintf("func (p *%s) Value() (driver.Value, error) {\n", eName)
	contents += "\tif p == nil {\n"
	contents += "\t\treturn nil, nil\n"
	contents += "\t}\n"
	contents += "\treturn int64(*p), nil\n"
	contents += "}\n\n"

	_, err := g.typesFile.WriteString(contents)
	return err
}

// GenerateStruct generates the given struct.
func (g *Generator) GenerateStruct(s *parser.Struct) error {
	contents := g.generateStruct(s, "")
	_, err := g.typesFile.WriteString(contents)
	return err
}

// GenerateUnion generates the given union.
func (g *Generator) GenerateUnion(union *parser.Struct) error {
	contents := g.generateStruct(union, "")
	_, err := g.typesFile.WriteString(contents)
	return err
}

// GenerateException generates the given exception.
func (g *Generator) GenerateException(exception *parser.Struct) error {
	contents := g.generateStruct(exception, "")
	contents += fmt.Sprintf("func (p *%s) Error() string {\n", title(exception.Name))
	contents += "\treturn p.String()\n"
	contents += "}\n"

	_, err := g.typesFile.WriteString(contents)
	return err
}

// generateServiceArgsResults generates the args and results objects for the
// given service.
func (g *Generator) generateServiceArgsResults(service *parser.Service) string {
	contents := ""
	for _, s := range g.GetServiceMethodTypes(service) {
		contents += g.generateStruct(s, service.Name)
	}
	return contents
}

func (g *Generator) generateStruct(s *parser.Struct, serviceName string) string {
	contents := ""

	sName := titleServiceName(s.Name, serviceName)
	contents += g.generateStructDeclaration(s, sName)
	contents += g.generateConstructor(s, sName)

	contents += g.generateGetters(s, sName)
	contents += g.generateCountSetFields(s, sName)

	contents += g.generateRead(s, sName)
	contents += g.generateWrite(s, sName)
	contents += g.generateToString(s, sName)

	return contents
}

func (g *Generator) generateStructDeclaration(s *parser.Struct, sName string) string {
	contents := ""
	if s.Comment != nil {
		contents += g.GenerateInlineComment(s.Comment, "")
	}

	contents += fmt.Sprintf("type %s struct {\n", sName)

	// Declare fields
	for _, field := range s.Fields {
		fName := title(field.Name)
		// All fields in a union are marked optional by default

		if field.Comment != nil {
			contents += g.GenerateInlineComment(field.Comment, "\t")
		}

		// Use the actual field name for annotations because the serialized
		// name needs to be the same for all languages
		thriftAnnotation := fmt.Sprintf("%s,%d", field.Name, field.ID)
		if field.Modifier == parser.Required {
			thriftAnnotation += ",required"
		}
		jsonAnnotation := field.Name
		if field.Modifier == parser.Optional {
			jsonAnnotation += ",omitempty"
		}
		annotation := fmt.Sprintf("`thrift:\"%s\" db:\"%s\" json:\"%s\"`", thriftAnnotation, field.Name, jsonAnnotation)

		goType := g.getGoTypeFromThriftTypePtr(field.Type, g.isPointerField(field))
		contents += fmt.Sprintf("\t%s %s %s\n", fName, goType, annotation)
	}

	contents += "}\n\n"
	return contents
}

func (g *Generator) generateConstructor(s *parser.Struct, sName string) string {
	contents := ""

	contents += fmt.Sprintf("func New%s() *%s {\n", sName, sName)
	contents += fmt.Sprintf("\treturn &%s{\n", sName)

	for _, field := range s.Fields {
		// Use the default if it exists and it's not a pointer field, otherwise the zero value is implicitly used
		if field.Default != nil && !g.isPointerField(field) {
			val := g.generateConstantValue(field.Type, field.Default)
			contents += fmt.Sprintf("\t\t%s: %s,\n", title(field.Name), val)
		}
	}

	contents += "\t}\n"
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateGetters(s *parser.Struct, sName string) string {
	contents := ""

	for _, field := range s.Fields {
		fName := title(field.Name)
		isPointer := g.isPointerField(field)
		goType := g.getGoTypeFromThriftTypePtr(field.Type, false)
		goPtrType := g.getGoTypeFromThriftTypePtr(field.Type, true)
		underlyingType := g.Frugal.UnderlyingType(field.Type)

		if field.Modifier == parser.Optional || isPointer {
			// Generate a default for getters
			contents += fmt.Sprintf("var %s_%s_DEFAULT %s", sName, fName, goType)
			if field.Default != nil {
				val := g.generateConstantValue(field.Type, field.Default)
				contents += fmt.Sprintf(" = %s", val)
			}
			contents += "\n\n"

			// Determines if the field is set
			contents += fmt.Sprintf("func (p *%s) IsSet%s() bool {\n", sName, fName)
			if isPointer || underlyingType.IsContainer() || (underlyingType.Name == "binary" && field.Default == nil) {
				// Compare these to nil
				contents += fmt.Sprintf("\treturn p.%s != nil\n", fName)
			} else if underlyingType.Name == "binary" {
				// Binary fields are byte slices, can't compare slices with ==
				contents += fmt.Sprintf("\treturn !bytes.Equal(p.%s, %s_%s_DEFAULT)\n", fName, sName, fName)
			} else {
				// Otherwise compare to default
				contents += fmt.Sprintf("\treturn p.%s != %s_%s_DEFAULT\n", fName, sName, fName)
			}
			contents += "}\n\n"
		}
		if isPointer {
			// Need to dereference the field before returning if it's a pointer
			maybePointer := ""
			if goType != goPtrType {
				maybePointer = "*"
			}
			contents += fmt.Sprintf("func (p *%s) Get%s() %s {\n", sName, fName, goType)
			contents += fmt.Sprintf("\tif !p.IsSet%s() {\n", fName)
			contents += fmt.Sprintf("\t\treturn %s_%s_DEFAULT\n", sName, fName)
			contents += "\t}\n"
			contents += fmt.Sprintf("\treturn %sp.%s\n", maybePointer, fName)
			contents += "}\n\n"

		} else {
			contents += fmt.Sprintf("func (p *%s) Get%s() %s {\n", sName, fName, g.getGoTypeFromThriftType(field.Type))
			contents += fmt.Sprintf("\treturn p.%s\n", fName)
			contents += "}\n\n"
		}
	}
	return contents
}

// generateCountSetFields generates a helper function to determine how many
// optional fields are set in a union.
func (g *Generator) generateCountSetFields(s *parser.Struct, sName string) string {
	contents := ""

	if s.Type == parser.StructTypeUnion {
		contents += fmt.Sprintf("func (p *%s) CountSetFields%s() int {\n", sName, sName)
		contents += "\tcount := 0\n"
		for _, field := range s.Fields {
			contents += fmt.Sprintf("\tif p.IsSet%s() {\n", title(field.Name))
			contents += "\t\tcount++\n"
			contents += "\t}\n"
		}
		contents += "\treturn count\n"
		contents += "}\n\n"
	}
	return contents
}

func (g *Generator) generateRead(s *parser.Struct, sName string) string {
	contents := ""

	contents += fmt.Sprintf("func (p *%s) Read(iprot thrift.TProtocol) error {\n", sName)
	contents += "\tif _, err := iprot.ReadStructBegin(); err != nil {\n"
	contents += "\t\treturn thrift.PrependError(fmt.Sprintf(\"%T read error: \", p), err)\n"
	contents += "\t}\n\n"
	for _, field := range s.Fields {
		// Generate variables to make sure required fields are present
		if field.Modifier == parser.Required {
			contents += fmt.Sprintf("\tisset%s := false\n", title(field.Name))
		}
	}
	contents += "\n"
	contents += "\tfor {\n"
	contents += "\t\t_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()\n"
	contents += "\t\tif err != nil {\n"
	contents += "\t\t\treturn thrift.PrependError(fmt.Sprintf(\"%T field %d read error: \", p, fieldId), err)\n"
	contents += "\t\t}\n"
	contents += "\t\tif fieldTypeId == thrift.STOP {\n"
	contents += "\t\t\tbreak\n"
	contents += "\t\t}\n"
	if len(s.Fields) > 0 {
		contents += "\t\tswitch fieldId {\n"
		for _, field := range s.Fields {
			contents += fmt.Sprintf("\t\tcase %d:\n", field.ID)
			contents += fmt.Sprintf("\t\t\tif err := p.ReadField%d(iprot); err != nil {\n", field.ID)
			contents += "\t\t\t\treturn err\n"
			contents += "\t\t\t}\n"
			if field.Modifier == parser.Required {
				contents += fmt.Sprintf("\t\t\tisset%s = true\n", title(field.Name))
			}
		}
		contents += "\t\tdefault:\n"
	}
	contents += "\t\t\tif err := iprot.Skip(fieldTypeId); err != nil {\n"
	contents += "\t\t\t\treturn err\n"
	contents += "\t\t\t}\n"
	if len(s.Fields) > 0 {
		contents += "\t\t}\n"
	}
	contents += "\t\tif err := iprot.ReadFieldEnd(); err != nil {\n"
	contents += "\t\t\treturn err\n"
	contents += "\t\t}\n"
	contents += "\t}\n"
	contents += "\tif err := iprot.ReadStructEnd(); err != nil {\n"
	contents += "\t\treturn thrift.PrependError(fmt.Sprintf(\"%T read struct end error: \", p), err)\n"
	contents += "\t}\n"
	for _, field := range s.Fields {
		if field.Modifier == parser.Required {
			fName := title(field.Name)
			contents += fmt.Sprintf("\tif !isset%s {\n", fName)
			errorMessage := fmt.Sprintf("Required field %s is not set", fName)
			contents += fmt.Sprintf("\t\treturn thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf(\"%s\"))\n", errorMessage)
			contents += "\t}\n"
		}
	}

	// Only one field can be set for a union, make sure that's the case
	if s.Type == parser.StructTypeUnion {
		contents += fmt.Sprintf("\tif c := p.CountSetFields%s(); c != 1 {\n", sName)
		contents += "\t\treturn thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf(\"%T read union: exactly one field must be set (%d set).\", p, c))\n"
		contents += "\t}\n"
	}

	contents += "\treturn nil\n"
	contents += "}\n\n"

	for _, field := range s.Fields {
		contents += g.generateReadField(sName, field)
	}
	return contents
}

func (g *Generator) generateWrite(s *parser.Struct, sName string) string {
	contents := ""

	contents += fmt.Sprintf("func (p *%s) Write(oprot thrift.TProtocol) error {\n", sName)

	// Only one field can be set for a union, make sure that's the case
	if s.Type == parser.StructTypeUnion {
		contents += fmt.Sprintf("\tif c := p.CountSetFields%s(); c != 1 {\n", sName)
		contents += "\t\treturn thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf(\"%T write union: exactly one field must be set (%d set).\", p, c))\n"
		contents += "\t}\n"
	}

	// Use actual struct name so it's consistent between languages
	contents += fmt.Sprintf("\tif err := oprot.WriteStructBegin(\"%s\"); err != nil {\n", s.Name)
	contents += "\t\treturn thrift.PrependError(fmt.Sprintf(\"%T write struct begin error: \", p), err)\n"
	contents += "\t}\n"

	for _, field := range s.Fields {
		contents += fmt.Sprintf("\tif err := p.writeField%d(oprot); err != nil {\n", field.ID)
		contents += "\t\treturn err\n"
		contents += "\t}\n"
	}

	contents += "\tif err := oprot.WriteFieldStop(); err != nil{\n"
	contents += "\t\treturn thrift.PrependError(\"write field stop error: \", err)\n"
	contents += "\t}\n"
	contents += "\tif err := oprot.WriteStructEnd(); err != nil {\n"
	contents += "\t\treturn thrift.PrependError(\"write struct stop error: \", err)\n"
	contents += "\t}\n"
	contents += "\treturn nil\n"
	contents += "}\n\n"

	for _, field := range s.Fields {
		contents += g.generateWriteField(sName, field)
	}

	return contents
}

func (g *Generator) generateToString(s *parser.Struct, sName string) string {
	contents := ""

	contents += fmt.Sprintf("func (p *%s) String() string {\n", sName)
	contents += "\tif p == nil {\n"
	contents += "\t\treturn \"<nil>\"\n"
	contents += "\t}\n"
	contents += fmt.Sprintf("\treturn fmt.Sprintf(\"%s(%%+v)\", *p)\n", sName)
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateReadField(structName string, field *parser.Field) string {
	contents := fmt.Sprintf("func (p *%s) ReadField%d(iprot thrift.TProtocol) error {\n", structName, field.ID)

	contents += g.generateReadFieldRec(field, true)

	contents += "\treturn nil\n"
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateReadFieldRec(field *parser.Field, first bool) string {
	// first indicates if this is the first recursive call
	// first time calls assign to struct members instead of generating variables
	eq := ":="
	prefix := ""
	fName := field.Name
	if first {
		eq = "="
		prefix = "p."
		fName = title(field.Name)
	}
	contents := ""

	isPointerField := g.isPointerField(field)
	underlyingType := g.Frugal.UnderlyingType(field.Type)
	goOrigType := g.getGoTypeFromThriftTypePtr(field.Type, false)
	goUnderlyingType := g.getGoTypeFromThriftTypePtr(underlyingType, false)

	isEnum := g.Frugal.IsEnum(underlyingType)
	if underlyingType.IsPrimitive() || isEnum {
		if !first {
			contents += fmt.Sprintf("\tvar %s%s %s\n", prefix, field.Name, goOrigType)
		}

		thriftType := ""
		switch underlyingType.Name {
		case "bool":
			thriftType = "Bool"
		case "byte", "i8":
			thriftType = "Byte"
		case "i16":
			thriftType = "I16"
		case "i32":
			thriftType = "I32"
		case "i64":
			thriftType = "I64"
		case "double":
			thriftType = "Double"
		case "string":
			thriftType = "String"
		case "binary":
			thriftType = "Binary"
		default:
			if isEnum {
				thriftType = "I32"
			} else {
				panic("unknown thrift type: " + underlyingType.Name)
			}
		}

		cast := ""
		// enums and typedefs need to be cast
		if isEnum || goOrigType != goUnderlyingType {
			cast = goOrigType
		}

		maybeAddress := ""
		// need to assign an address if the field is a pointer
		if isPointerField {
			maybeAddress = "&"
		}

		contents += fmt.Sprintf("\tif v, err := iprot.Read%s(); err != nil {\n", thriftType)
		contents += fmt.Sprintf("\t\treturn thrift.PrependError(\"error reading field %d: \", err)\n", field.ID)
		contents += "\t} else {\n"
		if cast == "" {
			contents += fmt.Sprintf("\t\t%s%s = %sv\n", prefix, fName, maybeAddress)
		} else {
			contents += fmt.Sprintf("\t\ttemp := %s(v)\n", cast)
			contents += fmt.Sprintf("\t\t%s%s = %stemp\n", prefix, fName, maybeAddress)
		}

		contents += "\t}\n"
	} else if g.Frugal.IsStruct(underlyingType) {
		// All structs types should start with a pointer
		// Need to extract the struct name from the package prefix
		// ie *base.APIException -> base.NewAPIException()
		lastInd := strings.LastIndex(goUnderlyingType, ".")
		if lastInd == -1 {
			lastInd = 0
		}
		initializer := fmt.Sprintf("%sNew%s()", goUnderlyingType[1:lastInd+1], goUnderlyingType[lastInd+1:])

		contents += fmt.Sprintf("\t%s%s %s %s\n", prefix, fName, eq, initializer)
		contents += fmt.Sprintf("\tif err := %s%s.Read(iprot); err != nil {\n", prefix, fName)
		contents += fmt.Sprintf("\t\treturn thrift.PrependError(fmt.Sprintf(\"%%T error reading struct: \", %s%s), err)\n", prefix, fName)
		contents += "\t}\n"
	} else if underlyingType.IsContainer() {
		maybePointer := ""
		if isPointerField {
			maybePointer = "*"
		}
		// TODO 2.0 use this to get the value reading code, respecting the type,
		// instead of the current code for list and set
		//valElem := getElem()
		//valField := parser.FieldFromType(underlyingType.ValueType, valElem)
		//valContents := g.generateReadFieldRec(valField, false)
		switch underlyingType.Name {
		case "list":
			contents += "\t_, size, err := iprot.ReadListBegin()\n"
			contents += "\tif err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error reading list begin: \", err)\n"
			contents += "\t}\n"
			if !isPointerField {
				contents += fmt.Sprintf("\t%s%s %s make(%s, 0, size)\n", prefix, fName, eq, goOrigType)
			} else {
				contents += fmt.Sprintf("\ttemp := make(%s, 0, size)\n", goOrigType)
				contents += fmt.Sprintf("\t%s%s %s &temp\n", prefix, fName, eq)
			}
			contents += "\tfor i := 0; i < size; i++ {\n"
			valElem := g.GetElem()
			valField := parser.FieldFromType(underlyingType.ValueType, valElem)
			valContents := g.generateReadFieldRec(valField, false)
			contents += valContents
			contents += fmt.Sprintf("\t\t%s%s%s = append(%s%s%s, %s)\n", maybePointer, prefix, fName, maybePointer, prefix, fName, valElem)
			contents += "\t}\n"
			contents += "\tif err := iprot.ReadListEnd(); err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error reading list end: \", err)\n"
			contents += "\t}\n"
		case "set":
			contents += "\t_, size, err := iprot.ReadSetBegin()\n"
			contents += "\tif err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error reading set begin: \", err)\n"
			contents += "\t}\n"
			if !isPointerField {
				contents += fmt.Sprintf("\t%s%s %s make(%s, size)\n", prefix, fName, eq, goOrigType)
			} else {
				contents += fmt.Sprintf("\ttemp := make(%s, size)\n", goOrigType)
				contents += fmt.Sprintf("\t%s%s %s &temp\n", prefix, fName, eq)
			}
			contents += "\tfor i := 0; i < size; i++ {\n"
			valElem := g.GetElem()
			valField := parser.FieldFromType(underlyingType.ValueType, valElem)
			valContents := g.generateReadFieldRec(valField, false)
			contents += valContents
			contents += fmt.Sprintf("\t\t(%s%s%s)[%s] = true\n", maybePointer, prefix, fName, valElem)
			contents += "\t}\n"
			contents += "\tif err := iprot.ReadSetEnd(); err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error reading set end: \", err)\n"
			contents += "\t}\n"
		case "map":
			contents += "\t_, _, size, err := iprot.ReadMapBegin()\n"
			contents += "\tif err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error reading map begin: \", err)\n"
			contents += "\t}\n"
			if !isPointerField {
				contents += fmt.Sprintf("\t%s%s %s make(%s, size)\n", prefix, fName, eq, goOrigType)
			} else {
				contents += fmt.Sprintf("\ttemp := make(%s, size)\n", goOrigType)
				contents += fmt.Sprintf("\t%s%s %s &temp\n", prefix, fName, eq)
			}
			contents += "\tfor i := 0; i < size; i++ {\n"
			keyElem := g.GetElem()
			keyField := parser.FieldFromType(underlyingType.KeyType, keyElem)
			contents += g.generateReadFieldRec(keyField, false)
			// TODO 2.0 use the valContents for all the collections
			valElem := g.GetElem()
			valField := parser.FieldFromType(underlyingType.ValueType, valElem)
			valContents := g.generateReadFieldRec(valField, false)
			contents += valContents
			contents += fmt.Sprintf("\t\t(%s%s%s)[%s] = %s\n", maybePointer, prefix, fName, keyElem, valElem)
			contents += "\t}\n"
			contents += "\tif err := iprot.ReadMapEnd(); err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error reading map end: \", err)\n"
			contents += "\t}\n"
		default:
			panic("unrecognized thrift type: " + underlyingType.Name)
		}

	}

	return contents
}

func (g *Generator) generateWriteField(structName string, field *parser.Field) string {
	contents := ""
	fName := title(field.Name)

	contents += fmt.Sprintf("func (p *%s) writeField%d(oprot thrift.TProtocol) error {\n", structName, field.ID)
	// If an optional field isn't set, it isn't written
	if field.Modifier == parser.Optional {
		contents += fmt.Sprintf("\tif p.IsSet%s() {\n", fName)
	}
	// Use actual field so it's consistent between languages
	contents += fmt.Sprintf("\tif err := oprot.WriteFieldBegin(\"%s\", %s, %d); err != nil {\n", field.Name, g.getEnumFromThriftType(field.Type), field.ID)
	contents += fmt.Sprintf("\t\treturn thrift.PrependError(fmt.Sprintf(\"%%T write field begin error %d:%s: \", p), err)\n", field.ID, field.Name)
	contents += "\t}\n"
	contents += g.generateWriteFieldRec(field, "p.")
	contents += "\tif err := oprot.WriteFieldEnd(); err != nil {\n"
	contents += fmt.Sprintf("\t\treturn thrift.PrependError(fmt.Sprintf(\"%%T write field end error %d:%s: \", p), err)\n", field.ID, field.Name)
	contents += "\t}\n"
	if field.Modifier == parser.Optional {
		contents += "\t}\n"
	}
	contents += "\treturn nil\n"
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateWriteFieldRec(field *parser.Field, prefix string) string {
	underlyingType := g.Frugal.UnderlyingType(field.Type)
	isPointerField := g.isPointerField(field)
	fName := title(field.Name)
	contents := ""

	isEnum := g.Frugal.IsEnum(underlyingType)
	if underlyingType.IsPrimitive() || isEnum {
		if isPointerField {
			prefix = "*" + prefix
		}

		write := "Write"
		switch underlyingType.Name {
		// Just typecast everything to get around typedefs
		case "bool":
			write += "Bool(bool(%s))"
		case "byte", "i8":
			write += "Byte(int8(%s))"
		case "i16":
			write += "I16(int16(%s))"
		case "i32":
			write += "I32(int32(%s))"
		case "i64":
			write += "I64(int64(%s))"
		case "double":
			write += "Double(float64(%s))"
		case "string":
			write += "String(string(%s))"
		case "binary":
			write += "Binary([]byte(%s))"
		default:
			if isEnum {
				write += "I32(int32(%s))"
			} else {
				panic("unknown thrift type: " + underlyingType.Name)
			}
		}
		write = fmt.Sprintf(write, prefix+fName)
		contents += fmt.Sprintf("\tif err := oprot.%s; err != nil {\n", write)
		contents += fmt.Sprintf("\t\treturn thrift.PrependError(fmt.Sprintf(\"%%T.%s (%d) field write error: \", p), err)\n", field.Name, field.ID)
		contents += "\t}\n"
	} else if g.Frugal.IsStruct(underlyingType) {
		contents += fmt.Sprintf("\tif err := %s.Write(oprot); err != nil {\n", prefix+fName)
		contents += fmt.Sprintf("\t\treturn thrift.PrependError(fmt.Sprintf(\"%%T error writing struct: \", %s), err)\n", prefix+fName)
		contents += "\t}\n"
	} else if underlyingType.IsContainer() {
		if isPointerField {
			prefix = "*" + prefix
		}
		valEnumType := g.getEnumFromThriftType(underlyingType.ValueType)
		valField := parser.FieldFromType(underlyingType.ValueType, "")

		switch underlyingType.Name {
		case "list":
			contents += fmt.Sprintf("\tif err := oprot.WriteListBegin(%s, len(%s)); err != nil {\n", valEnumType, prefix+fName)
			contents += "\t\treturn thrift.PrependError(\"error writing list begin: \", err)\n"
			contents += "\t}\n"
			contents += fmt.Sprintf("\tfor _, v := range %s {\n", prefix+fName)
			contents += g.generateWriteFieldRec(valField, "v")
			contents += "\t}\n"
			contents += "\tif err := oprot.WriteListEnd(); err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error writing list end: \", err)\n"
			contents += "\t}\n"
		case "set":
			contents += fmt.Sprintf("\tif err := oprot.WriteSetBegin(%s, len(%s)); err != nil {\n", valEnumType, prefix+fName)
			contents += "\t\treturn thrift.PrependError(\"error writing set begin: \", err)\n"
			contents += "\t}\n"
			contents += fmt.Sprintf("\tfor v, _ := range %s {\n", prefix+fName)
			contents += g.generateWriteFieldRec(valField, "v")
			contents += "\t}\n"
			contents += "\tif err := oprot.WriteSetEnd(); err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error writing set end: \", err)\n"
			contents += "\t}\n"
		case "map":
			keyEnumType := g.getEnumFromThriftType(underlyingType.KeyType)
			contents += fmt.Sprintf("\tif err := oprot.WriteMapBegin(%s, %s, len(%s)); err != nil {\n", keyEnumType, valEnumType, prefix+fName)
			contents += "\t\treturn thrift.PrependError(\"error writing map begin: \", err)\n"
			contents += "\t}\n"
			contents += fmt.Sprintf("\tfor k, v := range %s {\n", prefix+fName)
			keyField := parser.FieldFromType(underlyingType.KeyType, "")
			contents += g.generateWriteFieldRec(keyField, "k")
			contents += g.generateWriteFieldRec(valField, "v")
			contents += "\t}\n"
			contents += "\tif err := oprot.WriteMapEnd(); err != nil {\n"
			contents += "\t\treturn thrift.PrependError(\"error writing map end: \", err)\n"
			contents += "\t}\n"
		default:
			panic("unknow type: " + underlyingType.Name)
		}
	}

	return contents
}

// GenerateTypesImports generates the necessary Go types imports.
func (g *Generator) GenerateTypesImports(file *os.File) error {
	contents := "import (\n"
	contents += "\t\"bytes\"\n"
	contents += "\t\"fmt\"\n"
	// Enums need these for some reason
	if len(g.Frugal.Enums) > 0 {
		contents += "\t\"database/sql/driver\"\n"
		contents += "\t\"errors\"\n"
	}
	if g.Options[thriftImportOption] != "" {
		contents += "\t\"" + g.Options[thriftImportOption] + "\"\n"
	} else {
		contents += "\t\"git.apache.org/thrift.git/lib/go/thrift\"\n"
	}

	protections := ""
	pkgPrefix := g.Options[packagePrefixOption]
	for _, include := range g.Frugal.Includes {
		if imp, err := g.generateIncludeImport(include, pkgPrefix); err != nil {
			return err
		} else {
			contents += imp
		}
		protections += g.generateImportProtection(include)
	}

	contents += ")\n\n"
	contents += "// (needed to ensure safety because of naive import list construction.)\n"
	contents += "var _ = thrift.ZERO\n"
	contents += "var _ = fmt.Printf\n"
	contents += "var _ = bytes.Equal\n\n"
	contents += protections
	contents += "var GoUnusedProtection__ int\n"
	_, err := file.WriteString(contents)
	return err
}

// GenerateServiceResultArgsImports generates the necessary imports for service
// args and result types.
func (g *Generator) GenerateServiceResultArgsImports(file *os.File) error {
	contents := ""
	contents += "import (\n"
	contents += "\t\"bytes\"\n"
	contents += "\t\"fmt\"\n"
	if g.Options[thriftImportOption] != "" {
		contents += "\t\"" + g.Options[thriftImportOption] + "\"\n"
	} else {
		contents += "\t\"git.apache.org/thrift.git/lib/go/thrift\"\n"
	}

	protections := ""
	pkgPrefix := g.Options[packagePrefixOption]
	for _, include := range g.Frugal.Includes {
		if imp, err := g.generateIncludeImport(include, pkgPrefix); err != nil {
			return err
		} else {
			contents += imp
		}
		protections += g.generateImportProtection(include)
	}

	contents += ")\n\n"
	contents += "// (needed to ensure safety because of naive import list construction.)\n"
	contents += "var _ = thrift.ZERO\n"
	contents += "var _ = fmt.Printf\n"
	contents += "var _ = bytes.Equal\n\n"
	contents += protections

	_, err := file.WriteString(contents)
	return err
}

// GenerateServiceImports generates necessary imports for the given service.
func (g *Generator) GenerateServiceImports(file *os.File, s *parser.Service) error {
	imports := "import (\n"
	imports += "\t\"bytes\"\n"
	imports += "\t\"fmt\"\n"
	imports += "\t\"sync\"\n"
	if len(s.TwowayMethods()) > 0 {
		// Only non-oneway methods require the time package.
		imports += "\t\"time\"\n\n"
	}
	if g.Options[thriftImportOption] != "" {
		imports += "\t\"" + g.Options[thriftImportOption] + "\"\n"
	} else {
		imports += "\t\"git.apache.org/thrift.git/lib/go/thrift\"\n"
	}
	if g.Options[frugalImportOption] != "" {
		imports += "\t\"" + g.Options[frugalImportOption] + "\"\n"
	} else {
		imports += "\t\"github.com/Workiva/frugal/lib/go\"\n"
	}
	imports += "\t\"github.com/Sirupsen/logrus\"\n"

	pkgPrefix := g.Options[packagePrefixOption]
	includes, err := s.ReferencedIncludes()
	if err != nil {
		return err
	}
	for _, include := range includes {
		if imp, err := g.generateIncludeImport(include, pkgPrefix); err != nil {
			return err
		} else {
			imports += imp
		}
	}

	imports += ")\n\n"

	imports += "// (needed to ensure safety because of naive import list construction.)\n"
	imports += "var _ = thrift.ZERO\n"
	imports += "var _ = fmt.Printf\n"
	imports += "var _ = bytes.Equal\n"
	imports += "var _ = logrus.DebugLevel"

	_, err = file.WriteString(imports)
	return err
}

// GenerateScopeImports generates necessary imports for the given scope.
func (g *Generator) GenerateScopeImports(file *os.File, s *parser.Scope) error {
	imports := "import (\n"
	imports += "\t\"fmt\"\n"
	imports += "\t\"log\"\n\n"
	if g.Options[thriftImportOption] != "" {
		imports += "\t\"" + g.Options[thriftImportOption] + "\"\n"
	} else {
		imports += "\t\"git.apache.org/thrift.git/lib/go/thrift\"\n"
	}
	if g.Options[frugalImportOption] != "" {
		imports += "\t\"" + g.Options[frugalImportOption] + "\"\n"
	} else {
		imports += "\t\"github.com/Workiva/frugal/lib/go\"\n"
	}

	pkgPrefix := g.Options[packagePrefixOption]
	scopeIncludes, err := g.Frugal.ReferencedScopeIncludes()
	if err != nil {
		return err
	}
	for _, include := range scopeIncludes {
		if imp, err := g.generateIncludeImport(include, pkgPrefix); err != nil {
			return err
		} else {
			imports += imp
		}
	}

	imports += ")"

	_, err = file.WriteString(imports)
	return err
}

func (g *Generator) generateIncludeImport(include *parser.Include, pkgPrefix string) (string, error) {
	includeName := filepath.Base(include.Name)
	importPath := fmt.Sprintf("%s%s", pkgPrefix, includeNameToImport(includeName))
	namespace := g.Frugal.NamespaceForInclude(includeName, lang)

	_, vendored := include.Annotations.Vendor()
	vendored = vendored && g.useVendor()
	vendorPath := ""

	if namespace != nil {
		importPath = fmt.Sprintf("%s%s", pkgPrefix, includeNameToImport(namespace.Value))
		if nsVendorPath, ok := namespace.Annotations.Vendor(); ok {
			vendorPath = nsVendorPath
		}
	}

	// If -use-vendor is set and this include is vendored, honor the path
	// specified by the include's namespace vendor annotation.
	if vendored {
		if vendorPath == "" {
			return "", fmt.Errorf("Vendored include %s does not specify vendor path for go namespace",
				include.Name)
		}
		importPath = vendorPath
	}

	return fmt.Sprintf("\t\"%s\"\n", importPath), nil
}

func (g *Generator) generateImportProtection(include *parser.Include) string {
	includeName := filepath.Base(include.Name)
	namespace := g.Frugal.NamespaceForInclude(includeName, lang)
	if namespace != nil {
		includeName = namespace.Value
	}
	return fmt.Sprintf("var _ = %s.GoUnusedProtection__\n",
		includeNameToReference(includeName))
}

// GenerateConstants generates any static constants.
func (g *Generator) GenerateConstants(file *os.File, name string) error {
	if !g.generateConstants {
		return nil
	}
	constants := fmt.Sprintf("const delimiter = \"%s\"", globals.TopicDelimiter)
	_, err := file.WriteString(constants)
	if err != nil {
		return err
	}
	g.generateConstants = false
	return nil
}

// GeneratePublisher generates the publisher for the given scope.
func (g *Generator) GeneratePublisher(file *os.File, scope *parser.Scope) error {
	var (
		scopeLower = parser.LowercaseFirstLetter(scope.Name)
		scopeCamel = snakeToCamel(scope.Name)
		publisher  = ""
	)

	if scope.Comment != nil {
		publisher += g.GenerateInlineComment(scope.Comment, "")
	}
	args := ""
	if len(scope.Prefix.Variables) > 0 {
		prefix := ""
		for _, variable := range scope.Prefix.Variables {
			args += prefix + variable
			prefix = ", "
		}
		args += " string, "
	}

	publisher += fmt.Sprintf("type %sPublisher interface {\n", scopeCamel)
	publisher += "\tOpen() error\n"
	publisher += "\tClose() error\n"
	for _, op := range scope.Operations {
		publisher += fmt.Sprintf("\tPublish%s(ctx frugal.FContext, %sreq %s) error\n", op.Name, args, g.getGoTypeFromThriftType(op.Type))
	}
	publisher += "}\n\n"

	publisher += fmt.Sprintf("type %sPublisher struct {\n", scopeLower)
	publisher += "\ttransport frugal.FPublisherTransport\n"
	publisher += "\tprotocolFactory *frugal.FProtocolFactory\n"
	publisher += "\tmethods   map[string]*frugal.Method\n"
	publisher += "}\n\n"

	publisher += fmt.Sprintf("func New%sPublisher(provider *frugal.FScopeProvider, middleware ...frugal.ServiceMiddleware) %sPublisher {\n",
		scopeCamel, scopeCamel)
	publisher += "\ttransport, protocolFactory := provider.NewPublisher()\n"
	publisher += "\tmethods := make(map[string]*frugal.Method)\n"
	publisher += fmt.Sprintf("\tpublisher := &%sPublisher{\n", scopeLower)
	publisher += "\t\ttransport: transport,\n"
	publisher += "\t\tprotocolFactory:  protocolFactory,\n"
	publisher += "\t\tmethods:   methods,\n"
	publisher += "\t}\n"
	publisher += "\tmiddleware = append(middleware, provider.GetMiddleware()...)\n"
	for _, op := range scope.Operations {
		publisher += fmt.Sprintf("\tmethods[\"publish%s\"] = frugal.NewMethod(publisher, publisher.publish%s, \"publish%s\", middleware)\n",
			op.Name, op.Name, op.Name)
	}
	publisher += "\treturn publisher\n"
	publisher += "}\n\n"

	publisher += fmt.Sprintf("func (p *%sPublisher) Open() error {\n", scopeLower)

	publisher += "\treturn p.transport.Open()\n"
	publisher += "}\n\n"

	publisher += fmt.Sprintf("func (p *%sPublisher) Close() error {\n", scopeLower)
	publisher += "\treturn p.transport.Close()\n"
	publisher += "}\n\n"

	prefix := ""
	for _, op := range scope.Operations {
		publisher += prefix
		prefix = "\n\n"
		publisher += g.generatePublishMethod(scope, op, args)
	}

	_, err := file.WriteString(publisher)
	return err
}

func (g *Generator) generatePublishMethod(scope *parser.Scope, op *parser.Operation, args string) string {
	var (
		scopeLower = parser.LowercaseFirstLetter(scope.Name)
		publisher  = ""
	)

	if op.Comment != nil {
		publisher += g.GenerateInlineComment(op.Comment, "")
	}

	publisher += fmt.Sprintf("func (p *%sPublisher) Publish%s(ctx frugal.FContext, %sreq %s) error {\n",
		scopeLower, op.Name, args, g.getGoTypeFromThriftType(op.Type))
	publisher += fmt.Sprintf("\tret := p.methods[\"publish%s\"].Invoke(%s)\n", op.Name, g.generateScopeArgs(scope))
	publisher += "\tif ret[0] != nil {\n"
	publisher += "\t\treturn ret[0].(error)\n"
	publisher += "\t}\n"
	publisher += "\treturn nil\n"
	publisher += "}\n\n"

	publisher += g.generateInternalPublishMethod(scope, op, args)

	return publisher
}

func (g *Generator) generateInternalPublishMethod(scope *parser.Scope, op *parser.Operation, args string) string {
	var (
		scopeLower = parser.LowercaseFirstLetter(scope.Name)
		scopeTitle = strings.Title(scope.Name)
		publisher  = ""
	)

	publisher += fmt.Sprintf("func (p *%sPublisher) publish%s(ctx frugal.FContext, %sreq %s) error {\n",
		scopeLower, op.Name, args, g.getGoTypeFromThriftType(op.Type))

	// Inject the prefix variables into the FContext to send
	for _, prefixVar := range scope.Prefix.Variables {
		publisher += fmt.Sprintf("\tctx.AddRequestHeader(\"_topic_%s\", %s)\n", prefixVar, prefixVar)
	}

	publisher += fmt.Sprintf("\top := \"%s\"\n", op.Name)
	publisher += fmt.Sprintf("\tprefix := %s\n", generatePrefixStringTemplate(scope))
	publisher += "\ttopic := fmt.Sprintf(\"%s" + scopeTitle + "%s%s\", prefix, delimiter, op)\n"
	publisher += "\tbuffer := frugal.NewTMemoryOutputBuffer(p.transport.GetPublishSizeLimit())\n"
	publisher += "\toprot := p.protocolFactory.GetProtocol(buffer)\n"
	publisher += "\tif err := oprot.WriteRequestHeader(ctx); err != nil {\n"
	publisher += "\t\treturn err\n"
	publisher += "\t}\n"
	publisher += "\tif err := oprot.WriteMessageBegin(op, thrift.CALL, 0); err != nil {\n"
	publisher += "\t\treturn err\n"
	publisher += "\t}\n"
	publisher += g.generateWriteFieldRec(parser.FieldFromType(op.Type, ""), "req")
	publisher += "\tif err := oprot.WriteMessageEnd(); err != nil {\n"
	publisher += "\t\treturn err\n"
	publisher += "\t}\n"
	publisher += "\tif err := oprot.Flush(); err != nil {\n"
	publisher += "\t\treturn err\n"
	publisher += "\t}\n"
	publisher += "\treturn p.transport.Publish(topic, buffer.Bytes())\n"
	publisher += "}\n"
	return publisher
}

func generatePrefixStringTemplate(scope *parser.Scope) string {
	if len(scope.Prefix.Variables) == 0 {
		if scope.Prefix.String == "" {
			return `""`
		}
		return fmt.Sprintf(`"%s%s"`, scope.Prefix.String, globals.TopicDelimiter)
	}
	template := "fmt.Sprintf(\""
	template += scope.Prefix.Template("%s")
	template += globals.TopicDelimiter + "\", "
	prefix := ""
	for _, variable := range scope.Prefix.Variables {
		template += prefix + variable
		prefix = ", "
	}
	template += ")"
	return template
}

// GenerateSubscriber generates the subscriber for the given scope.
func (g *Generator) GenerateSubscriber(file *os.File, scope *parser.Scope) error {
	var (
		scopeLower = parser.LowercaseFirstLetter(scope.Name)
		scopeCamel = snakeToCamel(scope.Name)
		subscriber = ""
	)

	if scope.Comment != nil {
		subscriber += g.GenerateInlineComment(scope.Comment, "")
	}

	args := ""
	argsWithoutTypes := ""
	prefix := ""
	if len(scope.Prefix.Variables) > 0 {
		for _, variable := range scope.Prefix.Variables {
			args += prefix + variable
			prefix = ", "
		}
		argsWithoutTypes = args + ", "
		args += " string, "
	}

	subscriber += fmt.Sprintf("type %sSubscriber interface {\n", scopeCamel)
	for _, op := range scope.Operations {
		subscriber += fmt.Sprintf("\tSubscribe%s(%shandler func(frugal.FContext, %s)) (*frugal.FSubscription, error)\n",
			op.Name, args, g.getGoTypeFromThriftType(op.Type))
	}
	subscriber += "}\n\n"

	if scope.Comment != nil {
		subscriber += g.GenerateInlineComment(scope.Comment, "")
	}
	subscriber += fmt.Sprintf("type %sErrorableSubscriber interface {\n", scopeCamel)
	for _, op := range scope.Operations {
		subscriber += fmt.Sprintf("\tSubscribe%sErrorable(%shandler func(frugal.FContext, %s) error) (*frugal.FSubscription, error)\n",
			op.Name, args, g.getGoTypeFromThriftType(op.Type))
	}
	subscriber += "}\n\n"

	subscriber += fmt.Sprintf("type %sSubscriber struct {\n", scopeLower)
	subscriber += "\tprovider   *frugal.FScopeProvider\n"
	subscriber += "\tmiddleware []frugal.ServiceMiddleware\n"
	subscriber += "}\n\n"

	subscriber += fmt.Sprintf("func New%sSubscriber(provider *frugal.FScopeProvider, middleware ...frugal.ServiceMiddleware) %sSubscriber {\n",
		scopeCamel, scopeCamel)
	subscriber += "\tmiddleware = append(middleware, provider.GetMiddleware()...)\n"
	subscriber += fmt.Sprintf("\treturn &%sSubscriber{provider: provider, middleware: middleware}\n", scopeLower)
	subscriber += "}\n\n"

	subscriber += fmt.Sprintf("func New%sErrorableSubscriber(provider *frugal.FScopeProvider, middleware ...frugal.ServiceMiddleware) %sErrorableSubscriber {\n",
		scopeCamel, scopeCamel)
	subscriber += "\tmiddleware = append(middleware, provider.GetMiddleware()...)\n"
	subscriber += fmt.Sprintf("\treturn &%sSubscriber{provider: provider, middleware: middleware}\n", scopeLower)
	subscriber += "}\n\n"

	prefix = ""
	for _, op := range scope.Operations {
		subscriber += prefix
		prefix = "\n\n"
		subscriber += g.generateSubscribeMethod(scope, op, args, argsWithoutTypes)
	}

	_, err := file.WriteString(subscriber)
	return err
}

func (g *Generator) generateSubscribeMethod(scope *parser.Scope, op *parser.Operation, args, argsWithoutTypes string) string {
	var (
		scopeLower = parser.LowercaseFirstLetter(scope.Name)
		scopeTitle = strings.Title(scope.Name)
		subscriber = ""
	)
	if op.Comment != nil {
		subscriber += g.GenerateInlineComment(op.Comment, "")
	}

	subscriber += fmt.Sprintf("func (l *%sSubscriber) Subscribe%s(%shandler func(frugal.FContext, %s)) (*frugal.FSubscription, error) {\n",
		scopeLower, op.Name, args, g.getGoTypeFromThriftType(op.Type))
	subscriber += fmt.Sprintf("\treturn l.Subscribe%sErrorable(%sfunc(fctx frugal.FContext, arg %s) error {\n",
		op.Name, argsWithoutTypes, g.getGoTypeFromThriftType(op.Type))
	subscriber += "\t\thandler(fctx, arg)\n"
	subscriber += "\t\treturn nil\n"
	subscriber += "\t})\n"
	subscriber += "}\n\n"

	if op.Comment != nil {
		subscriber += g.GenerateInlineComment(op.Comment, "")
	}
	subscriber += fmt.Sprintf("func (l *%sSubscriber) Subscribe%sErrorable(%shandler func(frugal.FContext, %s) error) (*frugal.FSubscription, error) {\n",
		scopeLower, op.Name, args, g.getGoTypeFromThriftType(op.Type))
	subscriber += fmt.Sprintf("\top := \"%s\"\n", op.Name)
	subscriber += fmt.Sprintf("\tprefix := %s\n", generatePrefixStringTemplate(scope))
	subscriber += "\ttopic := fmt.Sprintf(\"%s" + scopeTitle + "%s%s\", prefix, delimiter, op)\n"
	subscriber += "\ttransport, protocolFactory := l.provider.NewSubscriber()\n"
	subscriber += fmt.Sprintf("\tcb := l.recv%s(op, protocolFactory, handler)\n", op.Name)
	subscriber += "\tif err := transport.Subscribe(topic, cb); err != nil {\n"
	subscriber += "\t\treturn nil, err\n"
	subscriber += "\t}\n\n"

	subscriber += "\tsub := frugal.NewFSubscription(topic, transport)\n"
	subscriber += "\treturn sub, nil\n"
	subscriber += "}\n\n"

	subscriber += fmt.Sprintf("func (l *%sSubscriber) recv%s(op string, pf *frugal.FProtocolFactory, handler func(frugal.FContext, %s) error) frugal.FAsyncCallback {\n",
		scopeLower, op.Name, g.getGoTypeFromThriftType(op.Type))
	subscriber += fmt.Sprintf("\tmethod := frugal.NewMethod(l, handler, \"Subscribe%s\", l.middleware)\n", op.Name)
	subscriber += "\treturn func(transport thrift.TTransport) error {\n"
	subscriber += "\t\tiprot := pf.GetProtocol(transport)\n"
	subscriber += "\t\tctx, err := iprot.ReadRequestHeader()\n"
	subscriber += "\t\tif err != nil {\n"
	subscriber += "\t\t\treturn err\n"
	subscriber += "\t\t}\n\n"
	subscriber += "\t\tname, _, _, err := iprot.ReadMessageBegin()\n"
	subscriber += "\t\tif err != nil {\n"
	subscriber += "\t\t\treturn err\n"
	subscriber += "\t\t}\n\n"
	subscriber += "\t\tif name != op {\n"
	subscriber += "\t\t\tiprot.Skip(thrift.STRUCT)\n"
	subscriber += "\t\t\tiprot.ReadMessageEnd()\n"
	subscriber += "\t\t\treturn thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN_METHOD, \"Unknown function\"+name)\n"
	subscriber += "\t\t}\n"
	subscriber += g.generateReadFieldRec(parser.FieldFromType(op.Type, "req"), false)
	subscriber += "\t\tiprot.ReadMessageEnd()\n\n"
	subscriber += "\t\treturn method.Invoke([]interface{}{ctx, req}).Error()\n"
	subscriber += "\t}\n"
	subscriber += "}"

	return subscriber
}

// GenerateService generates the given service.
func (g *Generator) GenerateService(file *os.File, s *parser.Service) error {
	contents := ""
	contents += g.generateServiceInterface(s)
	contents += g.generateClient(s)
	contents += g.generateServer(s)
	contents += g.generateServiceArgsResults(s)

	_, err := file.WriteString(contents)
	return err
}

func (g *Generator) generateServiceInterface(service *parser.Service) string {
	contents := ""
	if service.Comment != nil {
		contents += g.GenerateInlineComment(service.Comment, "")
	}

	contents += fmt.Sprintf("type F%s interface {\n", snakeToCamel(service.Name))
	if service.Extends != "" {
		contents += fmt.Sprintf("\t%s\n\n", g.getServiceExtendsName(service))
	}
	for _, method := range service.Methods {
		if method.Comment != nil {
			contents += g.GenerateInlineComment(method.Comment, "\t")
		}

		if _, ok := method.Annotations.Deprecated(); ok {
			contents += "\t// Deprecated\n"
		}

		contents += fmt.Sprintf("\t%s(ctx frugal.FContext%s) %s\n",
			snakeToCamel(method.Name), g.generateInterfaceArgs(method.Arguments),
			g.generateReturnArgs(method))
	}
	contents += "}\n\n"
	return contents
}

func (g *Generator) getServiceExtendsName(service *parser.Service) string {
	serviceName := "F" + service.ExtendsService()
	include := service.ExtendsInclude()
	if include != "" {
		if namespace := g.Frugal.NamespaceForInclude(include, lang); namespace != nil {
			include = namespace.Value
		}
		include = includeNameToReference(include)
		serviceName = include + "." + serviceName
	}
	return serviceName
}

func (g *Generator) getServiceExtendsNamespace(service *parser.Service) string {
	namespace := ""
	if service.ExtendsInclude() != "" {
		if ns := g.Frugal.NamespaceForInclude(service.ExtendsInclude(), lang); ns != nil {
			namespace = ns.Value
		} else {
			namespace = service.ExtendsInclude()
		}
		namespace = includeNameToReference(namespace)
		namespace += "."
	}
	return namespace
}

func (g *Generator) generateReturnArgs(method *parser.Method) string {
	if method.ReturnType == nil {
		return "(err error)"
	}
	return fmt.Sprintf("(r %s, err error)", g.getGoTypeFromThriftType(method.ReturnType))
}

func (g *Generator) generateAsyncReturnArgs(method *parser.Method) string {
	if method.ReturnType == nil {
		return "(err <-chan error)"
	}
	return fmt.Sprintf("(r <-chan %s, err <-chan error)", g.getGoTypeFromThriftType(method.ReturnType))
}

func (g *Generator) generateClient(service *parser.Service) string {
	servTitle := snakeToCamel(service.Name)
	contents := ""
	if service.Comment != nil {
		contents += g.GenerateInlineComment(service.Comment, "")
	}

	contents += fmt.Sprintf("type F%sClient struct {\n", servTitle)
	if service.Extends != "" {
		contents += fmt.Sprintf("\t*%sClient\n", g.getServiceExtendsName(service))
	}
	contents += "\ttransport       frugal.FTransport\n"
	contents += "\tprotocolFactory *frugal.FProtocolFactory\n"
	contents += "\tmethods         map[string]*frugal.Method\n"
	contents += "}\n\n"

	contents += fmt.Sprintf(
		"func NewF%sClient(provider *frugal.FServiceProvider, middleware ...frugal.ServiceMiddleware) *F%sClient {\n",
		servTitle, servTitle)
	contents += "\tmethods := make(map[string]*frugal.Method)\n"
	contents += fmt.Sprintf("\tclient := &F%sClient{\n", servTitle)
	if service.Extends != "" {
		contents += fmt.Sprintf("\t\tF%sClient: %sNewF%sClient(provider, middleware...),\n",
			service.ExtendsService(), g.getServiceExtendsNamespace(service), service.ExtendsService())
	}
	contents += "\t\ttransport:       provider.GetTransport(),\n"
	contents += "\t\tprotocolFactory: provider.GetProtocolFactory(),\n"
	contents += "\t\tmethods:         methods,\n"
	contents += "\t}\n"
	contents += "\tmiddleware = append(middleware, provider.GetMiddleware()...)\n"
	for _, method := range service.Methods {
		name := parser.LowercaseFirstLetter(method.Name)
		contents += fmt.Sprintf("\tmethods[\"%s\"] = frugal.NewMethod(client, client.%s, \"%s\", middleware)\n", name, name, name)
	}
	contents += "\treturn client\n"
	contents += "}\n\n"

	for _, method := range service.Methods {
		contents += g.generateClientMethod(service, method)
		if g.generateAsync() {
			contents += g.generateAsyncClientMethod(service, method)
		}
	}
	return contents
}

func (g *Generator) generateAsyncClientMethod(service *parser.Service, method *parser.Method) string {
	var (
		servTitle = snakeToCamel(service.Name)
		nameTitle = snakeToCamel(method.Name)
	)

	contents := ""
	if method.Comment != nil {
		contents += g.GenerateInlineComment(method.Comment, "")
	}
	contents += fmt.Sprintf("func (f *F%sClient) %sAsync(ctx frugal.FContext%s) %s {\n",
		servTitle, nameTitle, g.generateInputArgs(method.Arguments), g.generateAsyncReturnArgs(method))
	contents += "\terrC := make(chan error, 1)\n"
	if method.ReturnType != nil {
		contents += fmt.Sprintf("\tresultC := make(chan %s, 1)\n", g.getGoTypeFromThriftType(method.ReturnType))
	}
	contents += "\tgo func() {\n"
	if method.ReturnType == nil {
		contents += fmt.Sprintf("\t\terrC <- f.%s(%s)\n", nameTitle, g.generateCallArgs(method))
	} else {
		contents += fmt.Sprintf("\t\tresult, err := f.%s(%s)\n", nameTitle, g.generateCallArgs(method))
		contents += "\t\tif err != nil {\n"
		contents += "\t\t\terrC <- err\n"
		contents += "\t\t} else {\n"
		contents += "\t\t\tresultC <- result\n"
		contents += "\t\t}\n"
	}
	contents += "\t}()\n"
	if method.ReturnType == nil {
		contents += "\treturn errC\n"
	} else {
		contents += "\treturn resultC, errC\n"
	}
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateClientMethod(service *parser.Service, method *parser.Method) string {
	var (
		servTitle = snakeToCamel(service.Name)
		nameTitle = snakeToCamel(method.Name)
		nameLower = parser.LowercaseFirstLetter(method.Name)
	)

	contents := ""
	if method.Comment != nil {
		contents += g.GenerateInlineComment(method.Comment, "")
	}

	deprecationValue, deprecated := method.Annotations.Deprecated()
	if deprecated {
		if deprecationValue != "" {
			deprecationValue = ": " + deprecationValue
		}
		contents += fmt.Sprintf("// Deprecated%s\n", deprecationValue)
	}

	contents += fmt.Sprintf("func (f *F%sClient) %s(ctx frugal.FContext%s) %s {\n",
		servTitle, nameTitle, g.generateInputArgs(method.Arguments), g.generateReturnArgs(method))

	if deprecated {
		contents += fmt.Sprintf("\tlogrus.Warn(\"Call to deprecated function '%s.%s'\")\n", service.Name, nameTitle)
	}

	contents += fmt.Sprintf("\tret := f.methods[\"%s\"].Invoke(%s)\n", nameLower, g.generateClientArgs(method))
	numReturn := "2"
	if method.ReturnType == nil {
		numReturn = "1"
	}
	contents += fmt.Sprintf("\tif len(ret) != %s {\n", numReturn)
	contents += fmt.Sprintf("\t\tpanic(fmt.Sprintf(\"Middleware returned %%d arguments, expected %s\", len(ret)))\n", numReturn)
	contents += "\t}\n"
	if method.ReturnType != nil {
		contents += "\tif ret[0] != nil {\n"
		contents += fmt.Sprintf("\t\tr = ret[0].(%s)\n", g.getGoTypeFromThriftType(method.ReturnType))
		contents += "\t}\n"
		contents += "\tif ret[1] != nil {\n"
		contents += "\t\terr = ret[1].(error)\n"
		contents += "\t}\n"
		contents += "\treturn r, err\n"
	} else {
		contents += "\tif ret[0] != nil {\n"
		contents += "\t\terr = ret[0].(error)\n"
		contents += "\t}\n"
		contents += "\treturn err\n"
	}
	contents += "}\n\n"
	contents += g.generateInternalClientMethod(service, method)
	return contents
}

func (g *Generator) generateInternalClientMethod(service *parser.Service, method *parser.Method) string {
	var (
		servTitle = snakeToCamel(service.Name)
		nameTitle = snakeToCamel(method.Name)
		nameLower = parser.LowercaseFirstLetter(method.Name)
	)

	contents := ""
	contents += fmt.Sprintf("func (f *F%sClient) %s(ctx frugal.FContext%s) %s {\n",
		servTitle, nameLower, g.generateInputArgs(method.Arguments), g.generateReturnArgs(method))

	contents += "\tbuffer := frugal.NewTMemoryOutputBuffer(f.transport.GetRequestSizeLimit())\n"
	contents += "\toprot := f.protocolFactory.GetProtocol(buffer)\n"
	contents += "\tif err = oprot.WriteRequestHeader(ctx); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	msgType := "CALL"
	if method.Oneway {
		msgType = "ONEWAY"
	}
	contents += fmt.Sprintf(
		"\tif err = oprot.WriteMessageBegin(\"%s\", thrift.%s, 0); err != nil {\n", nameLower, msgType)
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += fmt.Sprintf("\targs := %s%sArgs{\n", servTitle, nameTitle)
	contents += g.generateStructArgs(method.Arguments)
	contents += "\t}\n"
	contents += "\tif err = args.Write(oprot); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += "\tif err = oprot.WriteMessageEnd(); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += "\tif err = oprot.Flush(); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"

	if method.Oneway {
		contents += "\terr = f.transport.Oneway(ctx, buffer.Bytes())\n"
		contents += "\treturn\n"
		contents += "}\n\n"
		return contents
	}
	contents += "\tvar resultTransport thrift.TTransport\n"
	contents += "\tresultTransport, err = f.transport.Request(ctx, buffer.Bytes())\n"
	contents += "\tif err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"

	contents += "\tiprot := f.protocolFactory.GetProtocol(resultTransport)\n"
	contents += "\tif err = iprot.ReadResponseHeader(ctx); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += "\tmethod, mTypeId, _, err := iprot.ReadMessageBegin()\n"
	contents += "\tif err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += fmt.Sprintf("\tif method != \"%s\" {\n", nameLower)
	contents += fmt.Sprintf(
		"\t\terr = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_WRONG_METHOD_NAME, \"%s failed: wrong method name\")\n", nameLower)
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += "\tif mTypeId == thrift.EXCEPTION {\n"
	contents += "\t\terror0 := thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_UNKNOWN, \"Unknown Exception\")\n"
	contents += "\t\tvar error1 thrift.TApplicationException\n"
	contents += "\t\terror1, err = error0.Read(iprot)\n"
	contents += "\t\tif err != nil {\n"
	contents += "\t\t\t\treturn\n"
	contents += "\t\t}\n"
	contents += "\t\tif err = iprot.ReadMessageEnd(); err != nil {\n"
	contents += "\t\t\treturn\n"
	contents += "\t\t}\n"
	contents += "\t\tif error1.TypeId() == frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE {\n"
	contents += "\t\t\terr = thrift.NewTTransportException(frugal.TRANSPORT_EXCEPTION_RESPONSE_TOO_LARGE, error1.Error())\n"
	contents += "\t\t\t\treturn\n"
	contents += "\t\t}\n"
	contents += "\t\terr = error1\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += "\tif mTypeId != thrift.REPLY {\n"
	contents += fmt.Sprintf(
		"\t\terr = thrift.NewTApplicationException(frugal.APPLICATION_EXCEPTION_INVALID_MESSAGE_TYPE, \"%s failed: invalid message type\")\n", nameLower)
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += fmt.Sprintf("\tresult := %s%sResult{}\n", servTitle, nameTitle)
	contents += "\tif err = result.Read(iprot); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	contents += "\tif err = iprot.ReadMessageEnd(); err != nil {\n"
	contents += "\t\treturn\n"
	contents += "\t}\n"
	for _, err := range method.Exceptions {
		errTitle := snakeToCamel(err.Name)
		contents += fmt.Sprintf("\tif result.%s != nil {\n", errTitle)
		contents += fmt.Sprintf("\t\terr = result.%s\n", errTitle)
		contents += "\t\treturn\n"
		contents += "\t}\n"
	}
	if method.ReturnType != nil {
		contents += "\tr = result.GetSuccess()\n"
	}
	contents += "\treturn\n"
	contents += "}\n\n"

	return contents
}

func (g *Generator) generateServer(service *parser.Service) string {
	contents := ""
	contents += g.generateProcessor(service)
	for _, method := range service.Methods {
		contents += g.generateMethodProcessor(service, method)
	}
	contents += g.generateWriteApplicationError(service)
	return contents
}

func (g *Generator) generateProcessor(service *parser.Service) string {
	var (
		servTitle = snakeToCamel(service.Name)
		servLower = strings.ToLower(service.Name)
		contents  = ""
	)

	contents += fmt.Sprintf("type F%sProcessor struct {\n", servTitle)
	if service.Extends == "" {
		contents += "\t*frugal.FBaseProcessor\n"
	} else {
		contents += fmt.Sprintf("\t*%sF%sProcessor\n",
			g.getServiceExtendsNamespace(service), service.ExtendsService())
	}
	contents += "}\n\n"

	contents += fmt.Sprintf("func NewF%sProcessor(handler F%s, middleware ...frugal.ServiceMiddleware) *F%sProcessor {\n",
		servTitle, servTitle, servTitle)
	if service.Extends != "" {
		contents += fmt.Sprintf("\tp := &F%sProcessor{%sNewF%sProcessor(handler, middleware...)}\n",
			servTitle, g.getServiceExtendsNamespace(service), service.ExtendsService())
	} else {
		contents += fmt.Sprintf("\tp := &F%sProcessor{frugal.NewFBaseProcessor()}\n", servTitle)
	}
	for _, method := range service.Methods {
		methodLower := parser.LowercaseFirstLetter(method.Name)
		contents += fmt.Sprintf(
			"\tp.AddToProcessorMap(\"%s\", &%sF%s{frugal.NewFBaseProcessorFunction(p.GetWriteMutex(), frugal.NewMethod(handler, handler.%s, \"%s\", middleware))})\n",
			methodLower, servLower, snakeToCamel(method.Name), snakeToCamel(method.Name), snakeToCamel(method.Name))
		if len(method.Annotations) > 0 {
			contents += fmt.Sprintf("\tp.AddToAnnotationsMap(\"%s\", map[string]string{\n", methodLower)
			for _, annotation := range method.Annotations {
				contents += fmt.Sprintf("\t\t\"%s\": %s,\n", annotation.Name, g.quote(annotation.Value))
			}
			contents += "\t})\n"
		}
	}

	contents += "\treturn p\n"
	contents += "}\n\n"

	return contents
}

func (g *Generator) generateMethodProcessor(service *parser.Service, method *parser.Method) string {
	var (
		servTitle = snakeToCamel(service.Name)
		servLower = strings.ToLower(service.Name)
		nameTitle = snakeToCamel(method.Name)
		nameLower = parser.LowercaseFirstLetter(method.Name)
	)

	contents := fmt.Sprintf("type %sF%s struct {\n", servLower, nameTitle)
	contents += "\t*frugal.FBaseProcessorFunction\n"
	contents += "}\n\n"

	contents += fmt.Sprintf("func (p *%sF%s) Process(ctx frugal.FContext, iprot, oprot *frugal.FProtocol) error {\n", servLower, nameTitle)

	if _, ok := method.Annotations.Deprecated(); ok {
		contents += fmt.Sprintf("\tlogrus.Warn(\"Deprecated function '%s.%s' was called by a client\")\n", service.Name, nameTitle)
	}

	contents += fmt.Sprintf("\targs := %s%sArgs{}\n", servTitle, nameTitle)
	contents += "\tvar err error\n"
	contents += "\tif err = args.Read(iprot); err != nil {\n"
	contents += "\t\tiprot.ReadMessageEnd()\n"
	if !method.Oneway {
		contents += "\t\tp.GetWriteMutex().Lock()\n"
		contents += fmt.Sprintf("\t\terr = %sWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_PROTOCOL_ERROR, \"%s\", err.Error())\n", servLower, nameLower)
		contents += "\t\tp.GetWriteMutex().Unlock()\n"
	}
	contents += "\t\treturn err\n"
	contents += "\t}\n\n"

	contents += "\tiprot.ReadMessageEnd()\n"
	if !method.Oneway {
		contents += fmt.Sprintf("\tresult := %s%sResult{}\n", servTitle, nameTitle)
	}
	contents += "\tvar err2 error\n"
	if method.ReturnType != nil {
	}
	contents += fmt.Sprintf("\tret := p.InvokeMethod(%s)\n", g.generateHandlerArgs(method))
	numReturn := "2"
	if method.ReturnType == nil {
		numReturn = "1"
	}
	contents += fmt.Sprintf("\tif len(ret) != %s {\n", numReturn)
	contents += fmt.Sprintf("\t\tpanic(fmt.Sprintf(\"Middleware returned %%d arguments, expected %s\", len(ret)))\n", numReturn)
	contents += "\t}\n"
	if method.ReturnType != nil {
		contents += "\tif ret[1] != nil {\n"
		contents += "\t\terr2 = ret[1].(error)\n"
		contents += "\t}\n"
	} else {
		contents += "\tif ret[0] != nil {\n"
		contents += "\t\terr2 = ret[0].(error)\n"
		contents += "\t}\n"
	}
	contents += "\tif err2 != nil {\n"
	contents += "\t\tif err3, ok := err2.(thrift.TApplicationException); ok {\n"
	contents += "\t\t\tp.GetWriteMutex().Lock()\n"
	contents += "\t\t\toprot.WriteResponseHeader(ctx)\n"
	contents += fmt.Sprintf("\t\t\toprot.WriteMessageBegin(\"%s\", thrift.EXCEPTION, 0)\n", nameLower)
	contents += "\t\t\terr3.Write(oprot)\n"
	contents += "\t\t\toprot.WriteMessageEnd()\n"
	contents += "\t\t\toprot.Flush()\n"
	contents += "\t\t\tp.GetWriteMutex().Unlock()\n"
	contents += "\t\t\treturn nil\n"
	contents += "\t\t}\n"
	if len(method.Exceptions) > 0 {
		contents += "\t\tswitch v := err2.(type) {\n"
		for _, err := range method.Exceptions {
			contents += fmt.Sprintf("\t\tcase %s:\n", g.getGoTypeFromThriftType(err.Type))
			contents += fmt.Sprintf("\t\t\tresult.%s = v\n", snakeToCamel(err.Name))
		}
		contents += "\t\tdefault:\n"
		contents += g.generateMethodException("\t\t\t", service, method)
		contents += "\t\t}\n"
	} else {
		contents += g.generateMethodException("\t\t", service, method)
	}
	if method.ReturnType != nil {
		contents += "\t} else {\n"
		contents += fmt.Sprintf("\t\tvar retval %s = ret[0].(%s)\n",
			g.getGoTypeFromThriftType(method.ReturnType), g.getGoTypeFromThriftType(method.ReturnType))
		if g.isPrimitive(method.ReturnType) || g.Frugal.IsEnum(method.ReturnType) {
			contents += "\t\tresult.Success = &retval\n"
		} else {
			contents += "\t\tresult.Success = retval\n"
		}
	}
	contents += "\t}\n"

	if method.Oneway {
		contents += "\treturn err\n"
		contents += "}\n\n"
		return contents
	}

	contents += "\tp.GetWriteMutex().Lock()\n"
	contents += "\tdefer p.GetWriteMutex().Unlock()\n"
	contents += "\tif err2 = oprot.WriteResponseHeader(ctx); err2 != nil {\n"
	contents += g.generateErrTooLarge(service, method)
	contents += "\t}\n"
	contents += fmt.Sprintf("\tif err2 = oprot.WriteMessageBegin(\"%s\", "+
		"thrift.REPLY, 0); err2 != nil {\n", nameLower)
	contents += g.generateErrTooLarge(service, method)
	contents += "\t}\n"
	contents += "\tif err2 = result.Write(oprot); err == nil && err2 != nil {\n"
	contents += g.generateErrTooLarge(service, method)
	contents += "\t}\n"
	contents += "\tif err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {\n"
	contents += g.generateErrTooLarge(service, method)
	contents += "\t}\n"
	contents += "\tif err2 = oprot.Flush(); err == nil && err2 != nil {\n"
	contents += g.generateErrTooLarge(service, method)
	contents += "\t}\n"
	contents += "\treturn err\n"
	contents += "}\n\n"

	return contents
}

func (g *Generator) generateClientArgs(method *parser.Method) string {
	args := "[]interface{}{ctx"
	for _, arg := range method.Arguments {
		args += ", " + strings.ToLower(arg.Name)
	}
	args += "}"
	return args
}

func (g *Generator) generateScopeArgs(scope *parser.Scope) string {
	args := "[]interface{}{ctx"
	for _, v := range scope.Prefix.Variables {
		args += ", " + v
	}
	args += ", req"
	args += "}"
	return args
}

func (g *Generator) generateHandlerArgs(method *parser.Method) string {
	args := "[]interface{}{ctx"
	for _, arg := range method.Arguments {
		args += ", args." + snakeToCamel(arg.Name)
	}
	args += "}"
	return args
}
func (g *Generator) generateCallArgs(method *parser.Method) string {
	args := "ctx"
	for _, arg := range method.Arguments {
		args += ", " + strings.ToLower(arg.Name)
	}
	return args
}

func (g *Generator) generateErrTooLarge(service *parser.Service, method *parser.Method) string {
	servLower := strings.ToLower(service.Name)
	nameLower := parser.LowercaseFirstLetter(method.Name)
	contents := "\t\tif frugal.IsErrTooLarge(err2) {\n"
	contents += fmt.Sprintf(
		"\t\t\t%sWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_RESPONSE_TOO_LARGE, \"%s\", err2.Error())\n",
		servLower, nameLower)
	contents += "\t\t\treturn nil\n"
	contents += "\t\t}\n"
	contents += "\t\terr = err2"
	return contents
}

func (g *Generator) generateMethodException(prefix string, service *parser.Service, method *parser.Method) string {
	contents := ""
	servLower := strings.ToLower(service.Name)
	nameLower := parser.LowercaseFirstLetter(method.Name)
	if !method.Oneway {
		contents += prefix + "p.GetWriteMutex().Lock()\n"
		msg := fmt.Sprintf("\"Internal error processing %s: \"+err2.Error()", nameLower)
		contents += fmt.Sprintf(
			prefix+"err2 := %sWriteApplicationError(ctx, oprot, frugal.APPLICATION_EXCEPTION_INTERNAL_ERROR, \"%s\", %s)\n", servLower, nameLower, msg)
		contents += prefix + "p.GetWriteMutex().Unlock()\n"
	}
	contents += prefix + "return err2\n"
	return contents
}

func (g *Generator) generateWriteApplicationError(service *parser.Service) string {
	servLower := strings.ToLower(service.Name)
	contents := fmt.Sprintf("func %sWriteApplicationError(ctx frugal.FContext, oprot *frugal.FProtocol, "+
		"type_ int32, method, message string) error {\n", servLower)
	contents += "\tx := thrift.NewTApplicationException(type_, message)\n"
	contents += "\toprot.WriteResponseHeader(ctx)\n"
	contents += "\toprot.WriteMessageBegin(method, thrift.EXCEPTION, 0)\n"
	contents += "\tx.Write(oprot)\n"
	contents += "\toprot.WriteMessageEnd()\n"
	contents += "\toprot.Flush()\n"
	contents += "\treturn x\n"
	contents += "}\n\n"
	return contents
}

func (g *Generator) generateInterfaceArgs(args []*parser.Field) string {
	argStr := ""
	for _, arg := range args {
		argStr += ", " + arg.Name + " " + g.getGoTypeFromThriftType(arg.Type)
	}
	return argStr
}

func (g *Generator) generateClientOutputArgs(args []*parser.Field) string {
	argStr := ""
	for _, arg := range args {
		argStr += ", " + strings.ToLower(arg.Name)
	}
	return argStr
}

func (g *Generator) generateInputArgs(args []*parser.Field) string {
	argStr := ""
	for _, arg := range args {
		argStr += ", " + strings.ToLower(arg.Name) + " " + g.getGoTypeFromThriftType(arg.Type)
	}
	return argStr
}

func (g *Generator) generateStructArgs(args []*parser.Field) string {
	argStr := ""
	for _, arg := range args {
		argStr += "\t\t" + snakeToCamel(arg.Name) + ": " + strings.ToLower(arg.Name) + ",\n"
	}
	return argStr
}

func (g *Generator) getGoTypeFromThriftType(t *parser.Type) string {
	return g.getGoTypeFromThriftTypePtr(t, false)
}

func (g *Generator) getGoTypeFromThriftTypePtr(t *parser.Type, pointer bool) string {
	maybePointer := ""
	if pointer {
		maybePointer = "*"
	}
	switch t.Name {
	case "bool":
		return maybePointer + "bool"
	case "byte", "i8":
		return maybePointer + "int8"
	case "i16":
		return maybePointer + "int16"
	case "i32":
		return maybePointer + "int32"
	case "i64":
		return maybePointer + "int64"
	case "double":
		return maybePointer + "float64"
	case "string":
		return maybePointer + "string"
	case "binary":
		return maybePointer + "[]byte"
	case "list":
		return fmt.Sprintf("%s[]%s", maybePointer,
			g.getGoTypeFromThriftTypePtr(t.ValueType, false))
	case "set":
		return fmt.Sprintf("%smap[%s]bool", maybePointer,
			g.getGoTypeFromThriftTypePtr(t.ValueType, false))
	case "map":
		return fmt.Sprintf("%smap[%s]%s", maybePointer,
			g.getGoTypeFromThriftTypePtr(t.KeyType, false),
			g.getGoTypeFromThriftTypePtr(t.ValueType, false))
	default:
		// Custom type, either typedef or struct.
		name := g.qualifiedTypeName(t)
		if g.Frugal.IsStruct(t) {
			// This is a struct, return a pointer to it.
			return "*" + name
		}
		return maybePointer + name
	}
}

func (g *Generator) getEnumFromThriftType(t *parser.Type) string {
	underlyingType := g.Frugal.UnderlyingType(t)
	switch underlyingType.Name {
	case "bool":
		return "thrift.BOOL"
	case "byte", "i8":
		return "thrift.BYTE"
	case "i16":
		return "thrift.I16"
	case "i32":
		return "thrift.I32"
	case "i64":
		return "thrift.I64"
	case "double":
		return "thrift.DOUBLE"
	case "string", "binary":
		return "thrift.STRING"
	case "list":
		return "thrift.LIST"
	case "set":
		return "thrift.SET"
	case "map":
		return "thrift.MAP"
	default:
		if g.Frugal.IsEnum(underlyingType) {
			return "thrift.I32"
		} else if g.Frugal.IsStruct(underlyingType) {
			return "thrift.STRUCT"
		}
		panic("not a valid thrift type: " + underlyingType.Name)
	}
}

func (g *Generator) isPrimitive(t *parser.Type) bool {
	underlyingType := g.Frugal.UnderlyingType(t)
	switch underlyingType.Name {
	case "bool", "byte", "i8", "i16", "i32", "i64", "double", "string":
		return true
	default:
		return false
	}
}

func (g *Generator) isPointerField(field *parser.Field) bool {
	underlyingType := g.Frugal.UnderlyingType(field.Type)
	// Structs as fields are always pointers
	if g.Frugal.IsStruct(underlyingType) {
		return true
	}
	// If it's not optional, it's not a pointer
	if field.Modifier != parser.Optional {
		return false
	}

	hasDefault := field.Default != nil
	switch underlyingType.Name {
	case "binary":
		// According to thrift, these are always like this, not sure why
		return false
	case "bool", "byte", "i8", "i16", "i32", "i64", "double", "string":
		// If there's no default, needs to be a pointer to be nillable
		return !hasDefault
	case "list", "set", "map":
		// slices and maps are nillable by default, use a pointer
		// if there's a default to differentiate between the default and
		// not set
		return hasDefault
	default:
		// Custom type, either typedef or struct-like.
		if g.Frugal.IsEnum(underlyingType) {
			// Same case as nums
			return !hasDefault
		}
		return hasDefault
	}
}

func (g *Generator) qualifiedTypeName(t *parser.Type) string {
	param := snakeToCamel(t.ParamName())
	include := t.IncludeName()
	if include != "" {
		name := include
		if namespace := g.Frugal.NamespaceForInclude(include, lang); namespace != nil {
			name = namespace.Value
		}
		param = fmt.Sprintf("%s.%s", includeNameToReference(name), param)
	}

	// The Thrift generator uses a convention of appending a suffix of '_'
	// if the argument starts with 'New', ends with 'Result' or ends with 'Args'.
	// This effort must be duplicated to correctly reference Thrift generated code.
	if strings.HasPrefix(param, "New") || strings.HasSuffix(param, "Result") || strings.HasSuffix(param, "Args") {
		param += "_"
	}
	return param
}

func (g *Generator) generateAsync() bool {
	_, ok := g.Options[asyncOption]
	return ok
}

func (g *Generator) useVendor() bool {
	_, ok := g.Options[useVendorOption]
	return ok
}

func includeNameToImport(includeName string) string {
	return strings.Replace(includeName, ".", "/", -1)
}

func includeNameToReference(includeName string) string {
	split := strings.FieldsFunc(includeName, func(r rune) bool {
		return r == '.' || r == '/'
	})
	return split[len(split)-1]
}

// snakeToCamel returns a string converted from snake case to uppercase.
func snakeToCamel(s string) string {
	var result string

	words := strings.Split(s, "_")

	for _, word := range words {
		if upper := strings.ToUpper(word); commonInitialisms[upper] {
			result += upper
			continue
		}

		w := []rune(word)
		w[0] = unicode.ToUpper(w[0])
		result += string(w)
	}

	return result
}

func title(name string) string {
	return titleServiceName(name, "")
}

func titleServiceName(name string, serviceName string) string {
	if len(name) == 0 {
		return name
	}

	// Keep screaming caps
	if name == strings.ToUpper(name) {
		return name
	}

	if serviceName != "" {
		name = fmt.Sprintf("%s_%s", serviceName, name)
	}
	var result string
	words := strings.Split(name, "_")

	for _, word := range words {
		if upper := strings.ToUpper(word); commonInitialisms[upper] {
			result += upper
			continue
		}

		w := []rune(word)
		w[0] = unicode.ToUpper(w[0])
		result += string(w)
	}

	if (serviceName == "") && (strings.HasPrefix(result, "New") || strings.HasSuffix(result, "Args") || strings.HasSuffix(result, "Result")) {
		result += "_"
	}

	return result
}

// startsWithInitialism returns the initialism if the given string begins with
// it.
func startsWithInitialism(s string) string {
	var initialism string
	// the longest initialism is 5 char, the shortest 2
	for i := 1; i <= 5; i++ {
		if len(s) > i-1 && commonInitialisms[s[:i]] {
			initialism = s[:i]
		}
	}
	return initialism
}

// commonInitialisms, taken from
// https://github.com/golang/lint/blob/3d26dc39376c307203d3a221bada26816b3073cf/lint.go#L482
var commonInitialisms = map[string]bool{
	"API":   true,
	"ASCII": true,
	"CPU":   true,
	"CSS":   true,
	"DNS":   true,
	"EOF":   true,
	"GUID":  true,
	"HTML":  true,
	"HTTP":  true,
	"HTTPS": true,
	"ID":    true,
	"IP":    true,
	"JSON":  true,
	"LHS":   true,
	"QPS":   true,
	"RAM":   true,
	"RHS":   true,
	"RPC":   true,
	"SLA":   true,
	"SMTP":  true,
	"SSH":   true,
	"TLS":   true,
	"TTL":   true,
	"UI":    true,
	"UID":   true,
	"UUID":  true,
	"URI":   true,
	"URL":   true,
	"UTF8":  true,
	"VM":    true,
	"XML":   true,
}
