#
# Autogenerated by Frugal Compiler (2.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.exceptions import TApplicationExceptionType
from frugal.exceptions import TTransportExceptionType
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.util.deprecate import deprecated
from frugal.util import make_hashable
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from thrift.transport.TTransport import TTransportException

import actual_base.python.f_BaseFoo
import actual_base.python.ttypes
import actual_base.python.constants
import validStructs.ttypes
import validStructs.constants
import ValidTypes.ttypes
import ValidTypes.constants
import subdir_include.ttypes
import subdir_include.constants
from .ttypes import *


class Iface(actual_base.python.f_BaseFoo.Iface):
    """
    This is a thrift service. Frugal will generate bindings that include
    a frugal Context for each service call.
    """

    @deprecated
    def Ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        
        deprecated: don't use this; use "something else"
        """
        pass

    def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        pass

    def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        pass

    def bin_method(self, ctx, bin, Str):
        """
        Args:
            ctx: FContext
            bin: binary string
            Str: string
        """
        pass

    def param_modifiers(self, ctx, opt_num, default_num, req_num):
        """
        Args:
            ctx: FContext
            opt_num: int (signed 32 bits)
            default_num: int (signed 32 bits)
            req_num: int (signed 32 bits)
        """
        pass

    def underlying_types_test(self, ctx, list_type, set_type):
        """
        Args:
            ctx: FContext
            list_type: list of int (signed 64 bits)
            set_type: set of int (signed 64 bits)
        """
        pass

    def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def use_subdir_struct(self, ctx, a):
        """
        Args:
            ctx: FContext
            a: subdir_include.A
        """
        pass


class Client(actual_base.python.f_BaseFoo.Client, Iface):

    def __init__(self, provider, middleware=None):
        """
        Create a new Client with an FServiceProvider containing a transport
        and protocol factory.

        Args:
            provider: FServiceProvider with TSynchronousTransport
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        middleware = middleware or []
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        super(Client, self).__init__(provider, middleware=middleware)
        middleware += provider.get_middleware()
        self._methods.update({
            'Ping': Method(self._Ping, middleware),
            'blah': Method(self._blah, middleware),
            'oneWay': Method(self._oneWay, middleware),
            'bin_method': Method(self._bin_method, middleware),
            'param_modifiers': Method(self._param_modifiers, middleware),
            'underlying_types_test': Method(self._underlying_types_test, middleware),
            'getThing': Method(self._getThing, middleware),
            'getMyInt': Method(self._getMyInt, middleware),
            'use_subdir_struct': Method(self._use_subdir_struct, middleware),
        })

    @deprecated
    def Ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        
        deprecated: don't use this; use "something else"
        """
        return self._methods['Ping']([ctx])

    def _Ping(self, ctx):
        self._send_Ping(ctx)
        self._recv_Ping(ctx)

    def _send_Ping(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
            args = Ping_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_Ping(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = Ping_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        return

    def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        return self._methods['blah']([ctx, num, Str, event])

    def _blah(self, ctx, num, Str, event):
        self._send_blah(ctx, num, Str, event)
        return self._recv_blah(ctx)

    def _send_blah(self, ctx, num, Str, event):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
            args = blah_args()
            args.num = num
            args.Str = Str
            args.event = event
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_blah(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = blah_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.awe is not None:
            raise result.awe
        if result.api is not None:
            raise result.api
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "blah failed: unknown result")
        raise x

    def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        return self._methods['oneWay']([ctx, id, req])

    def _oneWay(self, ctx, id, req):
        self._send_oneWay(ctx, id, req)

    def _send_oneWay(self, ctx, id, req):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('oneWay', TMessageType.CALL, 0)
            args = oneWay_args()
            args.id = id
            args.req = req
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_oneWay(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = oneWay_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        return

    def bin_method(self, ctx, bin, Str):
        """
        Args:
            ctx: FContext
            bin: binary string
            Str: string
        """
        return self._methods['bin_method']([ctx, bin, Str])

    def _bin_method(self, ctx, bin, Str):
        self._send_bin_method(ctx, bin, Str)
        return self._recv_bin_method(ctx)

    def _send_bin_method(self, ctx, bin, Str):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('bin_method', TMessageType.CALL, 0)
            args = bin_method_args()
            args.bin = bin
            args.Str = Str
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_bin_method(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = bin_method_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.api is not None:
            raise result.api
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "bin_method failed: unknown result")
        raise x

    def param_modifiers(self, ctx, opt_num, default_num, req_num):
        """
        Args:
            ctx: FContext
            opt_num: int (signed 32 bits)
            default_num: int (signed 32 bits)
            req_num: int (signed 32 bits)
        """
        return self._methods['param_modifiers']([ctx, opt_num, default_num, req_num])

    def _param_modifiers(self, ctx, opt_num, default_num, req_num):
        self._send_param_modifiers(ctx, opt_num, default_num, req_num)
        return self._recv_param_modifiers(ctx)

    def _send_param_modifiers(self, ctx, opt_num, default_num, req_num):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('param_modifiers', TMessageType.CALL, 0)
            args = param_modifiers_args()
            args.opt_num = opt_num
            args.default_num = default_num
            args.req_num = req_num
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_param_modifiers(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = param_modifiers_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "param_modifiers failed: unknown result")
        raise x

    def underlying_types_test(self, ctx, list_type, set_type):
        """
        Args:
            ctx: FContext
            list_type: list of int (signed 64 bits)
            set_type: set of int (signed 64 bits)
        """
        return self._methods['underlying_types_test']([ctx, list_type, set_type])

    def _underlying_types_test(self, ctx, list_type, set_type):
        self._send_underlying_types_test(ctx, list_type, set_type)
        return self._recv_underlying_types_test(ctx)

    def _send_underlying_types_test(self, ctx, list_type, set_type):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('underlying_types_test', TMessageType.CALL, 0)
            args = underlying_types_test_args()
            args.list_type = list_type
            args.set_type = set_type
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_underlying_types_test(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = underlying_types_test_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "underlying_types_test failed: unknown result")
        raise x

    def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getThing']([ctx])

    def _getThing(self, ctx):
        self._send_getThing(ctx)
        return self._recv_getThing(ctx)

    def _send_getThing(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getThing', TMessageType.CALL, 0)
            args = getThing_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getThing(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getThing_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getThing failed: unknown result")
        raise x

    def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['getMyInt']([ctx])

    def _getMyInt(self, ctx):
        self._send_getMyInt(ctx)
        return self._recv_getMyInt(ctx)

    def _send_getMyInt(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMyInt', TMessageType.CALL, 0)
            args = getMyInt_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_getMyInt(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = getMyInt_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "getMyInt failed: unknown result")
        raise x

    def use_subdir_struct(self, ctx, a):
        """
        Args:
            ctx: FContext
            a: subdir_include.A
        """
        return self._methods['use_subdir_struct']([ctx, a])

    def _use_subdir_struct(self, ctx, a):
        self._send_use_subdir_struct(ctx, a)
        return self._recv_use_subdir_struct(ctx)

    def _send_use_subdir_struct(self, ctx, a):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.timeout)
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('use_subdir_struct', TMessageType.CALL, 0)
            args = use_subdir_struct_args()
            args.a = a
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_use_subdir_struct(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            if x.type == TApplicationExceptionType.RESPONSE_TOO_LARGE:
                raise TTransportException(type=TTransportExceptionType.RESPONSE_TOO_LARGE, message=x.message)
            raise x
        result = use_subdir_struct_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationExceptionType.MISSING_RESULT, "use_subdir_struct failed: unknown result")
        raise x

class Processor(actual_base.python.f_BaseFoo.Processor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__(handler, middleware=middleware)
        self.add_to_processor_map('ping', _Ping(Method(handler.Ping, middleware), self.get_write_lock()))
        self.add_to_annotations_map('ping', {'deprecated': "don't use this; use \"something else\""})
        self.add_to_processor_map('blah', _blah(Method(handler.blah, middleware), self.get_write_lock()))
        self.add_to_processor_map('oneWay', _oneWay(Method(handler.oneWay, middleware), self.get_write_lock()))
        self.add_to_processor_map('bin_method', _bin_method(Method(handler.bin_method, middleware), self.get_write_lock()))
        self.add_to_processor_map('param_modifiers', _param_modifiers(Method(handler.param_modifiers, middleware), self.get_write_lock()))
        self.add_to_processor_map('underlying_types_test', _underlying_types_test(Method(handler.underlying_types_test, middleware), self.get_write_lock()))
        self.add_to_processor_map('getThing', _getThing(Method(handler.getThing, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMyInt', _getMyInt(Method(handler.getMyInt, middleware), self.get_write_lock()))
        self.add_to_processor_map('use_subdir_struct', _use_subdir_struct(Method(handler.use_subdir_struct, middleware), self.get_write_lock()))


class _Ping(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_Ping, self).__init__(handler, lock)

    @deprecated
    def process(self, ctx, iprot, oprot):
        args = Ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = Ping_result()
        try:
            self._handler([ctx])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "ping", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "ping", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "ping", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _blah(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_blah, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = blah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blah_result()
        try:
            result.success = self._handler([ctx, args.num, args.Str, args.event])
        except AwesomeException as awe:
            result.awe = awe
        except actual_base.python.ttypes.api_exception as api:
            result.api = api
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "blah", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "blah", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('blah', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "blah", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _oneWay(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_oneWay, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = oneWay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler([ctx, args.id, args.req])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "oneWay", exception=ex)
                return
        except Exception as e:
            raise


class _bin_method(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_bin_method, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = bin_method_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bin_method_result()
        try:
            result.success = self._handler([ctx, args.bin, args.Str])
        except actual_base.python.ttypes.api_exception as api:
            result.api = api
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "bin_method", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "bin_method", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('bin_method', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "bin_method", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _param_modifiers(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_param_modifiers, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = param_modifiers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = param_modifiers_result()
        try:
            result.success = self._handler([ctx, args.opt_num, args.default_num, args.req_num])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "param_modifiers", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "param_modifiers", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('param_modifiers', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "param_modifiers", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _underlying_types_test(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_underlying_types_test, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = underlying_types_test_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = underlying_types_test_result()
        try:
            result.success = self._handler([ctx, args.list_type, args.set_type])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "underlying_types_test", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "underlying_types_test", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('underlying_types_test', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "underlying_types_test", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getThing(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getThing, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getThing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getThing_result()
        try:
            result.success = self._handler([ctx])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getThing", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getThing", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getThing', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getThing", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _getMyInt(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_getMyInt, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = getMyInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMyInt_result()
        try:
            result.success = self._handler([ctx])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMyInt", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "getMyInt", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMyInt', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "getMyInt", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


class _use_subdir_struct(FProcessorFunction):

    def __init__(self, handler, lock):
        super(_use_subdir_struct, self).__init__(handler, lock)

    def process(self, ctx, iprot, oprot):
        args = use_subdir_struct_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = use_subdir_struct_result()
        try:
            result.success = self._handler([ctx, args.a])
        except TApplicationException as ex:
            with self._lock:
                _write_application_exception(ctx, oprot, "use_subdir_struct", exception=ex)
                return
        except Exception as e:
            with self._lock:
                _write_application_exception(ctx, oprot, "use_subdir_struct", ex_code=TApplicationExceptionType.INTERNAL_ERROR, message=e.message)
            raise
        with self._lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('use_subdir_struct', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except TTransportException as e:
                # catch a request too large error because the TMemoryOutputBuffer always throws that if too much data is written
                if e.type == TTransportExceptionType.REQUEST_TOO_LARGE:
                    raise _write_application_exception(ctx, oprot, "use_subdir_struct", ex_code=TApplicationExceptionType.RESPONSE_TOO_LARGE, message=e.args[0])
                else:
                    raise e


def _write_application_exception(ctx, oprot, method, ex_code=None, message=None, exception=None):
    if exception is not None:
        x = exception
    else:
        x = TApplicationException(type=ex_code, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class Ping_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('Ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class Ping_result(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('Ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blah_args(object):
    """
    Attributes:
     - num
     - Str
     - event
    """
    def __init__(self, num=None, Str=None, event=None):
        self.num = num
        self.Str = Str
        self.event = event

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Str = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.event = Event()
                    self.event.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blah_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.Str is not None:
            oprot.writeFieldBegin('Str', TType.STRING, 2)
            oprot.writeString(self.Str)
            oprot.writeFieldEnd()
        if self.event is not None:
            oprot.writeFieldBegin('event', TType.STRUCT, 3)
            self.event.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.num))
        value = (value * 31) ^ hash(make_hashable(self.Str))
        value = (value * 31) ^ hash(make_hashable(self.event))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blah_result(object):
    """
    Attributes:
     - success
     - awe
     - api
    """
    def __init__(self, success=None, awe=None, api=None):
        self.success = success
        self.awe = awe
        self.api = api

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.awe = AwesomeException()
                    self.awe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.api = actual_base.python.ttypes.api_exception()
                    self.api.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('blah_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.awe is not None:
            oprot.writeFieldBegin('awe', TType.STRUCT, 1)
            self.awe.write(oprot)
            oprot.writeFieldEnd()
        if self.api is not None:
            oprot.writeFieldBegin('api', TType.STRUCT, 2)
            self.api.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.awe))
        value = (value * 31) ^ hash(make_hashable(self.api))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class oneWay_args(object):
    """
    Attributes:
     - id
     - req
    """
    def __init__(self, id=None, req=None):
        self.id = id
        self.req = req

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.req = {}
                    (_, _, elem42) = iprot.readMapBegin()
                    for _ in range(elem42):
                        elem44 = iprot.readI32()
                        elem43 = iprot.readString()
                        self.req[elem44] = elem43
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('oneWay_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.req))
            for elem46, elem45 in self.req.items():
                oprot.writeI32(elem46)
                oprot.writeString(elem45)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.id))
        value = (value * 31) ^ hash(make_hashable(self.req))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class bin_method_args(object):
    """
    Attributes:
     - bin
     - Str
    """
    def __init__(self, bin=None, Str=None):
        self.bin = bin
        self.Str = Str

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bin = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Str = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('bin_method_args')
        if self.bin is not None:
            oprot.writeFieldBegin('bin', TType.STRING, 1)
            oprot.writeBinary(self.bin)
            oprot.writeFieldEnd()
        if self.Str is not None:
            oprot.writeFieldBegin('Str', TType.STRING, 2)
            oprot.writeString(self.Str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.bin))
        value = (value * 31) ^ hash(make_hashable(self.Str))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class bin_method_result(object):
    """
    Attributes:
     - success
     - api
    """
    def __init__(self, success=None, api=None):
        self.success = success
        self.api = api

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.api = actual_base.python.ttypes.api_exception()
                    self.api.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('bin_method_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.api is not None:
            oprot.writeFieldBegin('api', TType.STRUCT, 1)
            self.api.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        value = (value * 31) ^ hash(make_hashable(self.api))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class param_modifiers_args(object):
    """
    Attributes:
     - opt_num
     - default_num
     - req_num
    """
    def __init__(self, opt_num=None, default_num=None, req_num=None):
        self.opt_num = opt_num
        self.default_num = default_num
        self.req_num = req_num

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.opt_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.default_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.req_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('param_modifiers_args')
        if self.opt_num is not None:
            oprot.writeFieldBegin('opt_num', TType.I32, 1)
            oprot.writeI32(self.opt_num)
            oprot.writeFieldEnd()
        if self.default_num is not None:
            oprot.writeFieldBegin('default_num', TType.I32, 2)
            oprot.writeI32(self.default_num)
            oprot.writeFieldEnd()
        if self.req_num is not None:
            oprot.writeFieldBegin('req_num', TType.I32, 3)
            oprot.writeI32(self.req_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.req_num is None:
            raise TProtocol.TProtocolException(type=TProtocol.TProtocolException.INVALID_DATA, message='Required field req_num is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.opt_num))
        value = (value * 31) ^ hash(make_hashable(self.default_num))
        value = (value * 31) ^ hash(make_hashable(self.req_num))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class param_modifiers_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('param_modifiers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class underlying_types_test_args(object):
    """
    Attributes:
     - list_type
     - set_type
    """
    def __init__(self, list_type=None, set_type=None):
        self.list_type = list_type
        self.set_type = set_type

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.list_type = []
                    (_, elem47) = iprot.readListBegin()
                    for _ in range(elem47):
                        elem48 = iprot.readI64()
                        self.list_type.append(elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.set_type = set()
                    (_, elem49) = iprot.readSetBegin()
                    for _ in range(elem49):
                        elem50 = iprot.readI64()
                        self.set_type.add(elem50)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('underlying_types_test_args')
        if self.list_type is not None:
            oprot.writeFieldBegin('list_type', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.list_type))
            for elem51 in self.list_type:
                oprot.writeI64(elem51)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.set_type is not None:
            oprot.writeFieldBegin('set_type', TType.SET, 2)
            oprot.writeSetBegin(TType.I64, len(self.set_type))
            for elem52 in self.set_type:
                oprot.writeI64(elem52)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.list_type))
        value = (value * 31) ^ hash(make_hashable(self.set_type))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class underlying_types_test_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem53) = iprot.readListBegin()
                    for _ in range(elem53):
                        elem54 = iprot.readI64()
                        self.success.append(elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('underlying_types_test_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for elem55 in self.success:
                oprot.writeI64(elem55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getThing_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getThing_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getThing_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = validStructs.ttypes.Thing()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getThing_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMyInt_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMyInt_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMyInt_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('getMyInt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class use_subdir_struct_args(object):
    """
    Attributes:
     - a
    """
    def __init__(self, a=None):
        self.a = a

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.a = subdir_include.ttypes.A()
                    self.a.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('use_subdir_struct_args')
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.STRUCT, 1)
            self.a.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.a))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class use_subdir_struct_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = subdir_include.ttypes.A()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        self.validate()

    def write(self, oprot):
        self.validate()
        oprot.writeStructBegin('use_subdir_struct_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(make_hashable(self.success))
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

